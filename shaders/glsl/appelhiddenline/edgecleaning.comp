#version 450
#extension GL_EXT_debug_printf : enable
#define SCALECNT 16
//compute2

//const float FLT_MAX = 3.402823466e+38;

struct Vertex{
    vec3 position;
    vec3 normal;
    vec3 faceNor;
    vec3 symFaceNor;
    vec2 uv;
    int objectID;
    int faceID;
    int border;
    int heID;
    int uniqueID;
    int debug;
    int globalHeID;
};

layout (set = 0, binding = 0) buffer Vers
{
    Vertex vertices[];
};

//uniform和buffer一定不能搞错
//uniform结构要和CPU上定义的结构内变量一致
layout (set = 0, binding = 1) uniform UBO
{
   mat4 view;
   mat4 proj;
   uint edgeVertSize;
   uint origEdgeCnt; //现在简单实现用，用于记录加入假edge前有多少edge
}ubo;

//符合的edge数
layout (set = 0, binding = 2) buffer SBO1
{
   uint targetEdgeCnt;
};

//每个edge的GlobalHeID
layout (set = 0, binding = 3) buffer SBO2
{
   int targetEdgeIdxList[];
};

layout (set = 0, binding = 4) buffer SBO3
{
   float targetEdgeAABB[];
};

layout (local_size_x = 64) in;



void main() 
{
//    debugPrintfEXT("nh");
//    debugPrintfEXT("index=%u pos=(%.2f, %.2f, %.2f)\n", 1, vertices[0].position.x, vertices[0].position.y, vertices[0].position.z);
//    Vertex v1 = vertices[targetEdgeIdxList[targetEdgeCnt] * 2];
//    debugPrintfEXT("index=%u pos=(%.2f, %.2f, %.2f)\n", targetEdgeCnt, v1.position.x, v1.position.y, v1.position.z);
//    uint index1 = gl_GlobalInvocationID.x * 2;
//    uint index2 = index1 + 1;
//
//    if( index1 >= ubo.edgeVertSize ) return;
//
//    vertices[index1].debug = 0;
//    vertices[index2].debug = 0;

    //所有edge debug设为0
    if(gl_GlobalInvocationID.x < ubo.edgeVertSize){
        //debugPrintfEXT("pos=(%u,", targetEdgeCnt);
        uint index1 = gl_GlobalInvocationID.x * 2;
        uint index2 = index1 + 1;
        vertices[index1].debug = 0;
        vertices[index2].debug = 0;
        //vertices[index1].normal = vec3(1,0,0);
        //vertices[index2].normal = vec3(0,1,0);
        if(gl_GlobalInvocationID.x >= ubo.origEdgeCnt){
            //debugPrintfEXT("pos=(%u, %u)", ubo.edgeVertSize, ubo.origEdgeCnt);
            vertices[index1].position = vec3(0);
            vertices[index2].position = vec3(0);

        }
    }

    //计算AABB
//    if(gl_GlobalInvocationID.x < targetEdgeCnt){
//        int globalEdgeId = targetEdgeIdxList[gl_GlobalInvocationID.x];
//        //debugPrintfEXT("pos=(%u, %u)", ubo.edgeVertSize, targetEdgeCnt);
//        Vertex v1 = vertices[globalEdgeId * 2];
//        Vertex v2 = vertices[globalEdgeId * 2 + 1];
//        //vertices[index1].debug = 1;
//        //vertices[index2].debug = 1;
//        //计算AABB
//        vec3 v1Pos = vec3(ubo.proj * ubo.view * (vec4(v1.position, 1)));
//        vec3 v2Pos = vec3(ubo.proj * ubo.view * (vec4(v2.position, 1)));
//        float maxx;
//        float minx;
//        float maxy;
//        float miny;
//        if(v1Pos.x > v2Pos.x){
//            maxx = v1Pos.x;
//            minx = v2Pos.x;
//        }else{
//            maxx = v2Pos.x;
//            minx = v1Pos.x;
//        }
//        if(v1Pos.y > v2Pos.y){
//            maxy = v1Pos.y;
//            miny = v2Pos.y;
//        }else{
//            maxy = v2Pos.y;
//            miny = v1Pos.y;
//        }
//        //这里不能使用gl_GlobalInvocationID.x进行索引
//        //因为globalEdgeId每帧都在变化，因为它是在edgeCmdBuf中更改的
//        //而edgeCmdBuf每帧都在运行，所以这里索引只能用globalHeID
//        targetEdgeAABB[globalEdgeId * 4] = maxx;
//        targetEdgeAABB[globalEdgeId * 4 + 1] = minx;
//        targetEdgeAABB[globalEdgeId * 4 + 2] = maxy;
//        targetEdgeAABB[globalEdgeId * 4 + 3] = miny;
//        //debugPrintfEXT("pos=(%u, %.5f, %.5f, %.5f, %.5f, %.5f,%.5f,%.5f,%.5f)\n",targetEdgeIdx, v1.position.x, v1.position.y, v2.position.x, v2.position.y, v1Pos.x, v1Pos.y, v2Pos.x, v2Pos.y);
//    }
}

