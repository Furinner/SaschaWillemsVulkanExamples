#version 450
#extension GL_EXT_debug_printf : enable
#define SCALECNT 16
//compute1

const int MAX_INTER = 50;
const int MAX_BEDGES = 500; //一个bSeg最多由多少bEdges组成
const int IMG_WIDTH = 3840;
const int IMG_HEIGHT = 2160;

struct Vertex{
    vec3 position;
    vec3 normal;
    vec3 faceNor;
    vec3 symFaceNor;
    vec2 uv;
    int objectID;
    int faceID;
    int border;
    int heID;
    int uniqueID;
    int debug;
    int globalHeID;  //v1和v2一样，乘以2就变成了vertices2中的idx
};

layout (set = 0, binding = 0) uniform isampler2D scaleSamples[SCALECNT]; // 定长数组

layout (set = 0, binding = 1) buffer Vers
{
    //he1 v1, he1 v2, he2 v1, he2 v2,...,
    Vertex vertices[];
};

//uniform和buffer一定不能搞错
layout (set = 0, binding = 2) uniform UBO
{
   mat4 view;
   mat4 proj;
   uint bEdgeCnt; //两个顶点只记一次
   uint edgeVertSize;
   uint origEdgeCnt; //现在简单实现用，用于记录加入假edge前有多少edge
}ubo;

layout (set = 0, binding = 3) buffer SBO1
{
   //边界和silhouette的edge数，两个顶点只记一次
   uint targetEdgeCnt;
};

layout (set = 0, binding = 4) buffer SBO2
{
   //边界和silhouette的edge的globalHeID，两个顶点只记一次
   int targetEdgeIdxList[];
};

layout (set = 0, binding = 5) buffer SBO3
{
   float targetEdgeAABB[];
};

layout (set = 0, binding = 6) buffer SBO4
{
   //从0开始，记录假edge的数量
   uint edgeSuccessCnt;
};

layout (set = 0, binding = 7) buffer SBO5
{
   //he1 startIdx, he1 endIdx, he2 startIdx, he2 endIdx,...
   //有可能startIdx == endIdx，即没有edge，这个要自己判断
   int bEdgesSE[];
};

const float FLOAT_MAX = 3.402823466e+38;

layout (local_size_x = 64) in;

//maxx, minx, maxy, miny
bool twoBBInter(float ab1, float ab2, float ab3, float ab4, float oab1, float oab2, float oab3, float oab4){
    if((ab1 < oab2) || (ab2 > oab1)){
        return false;
    }
    if((ab3 < oab4) || (ab4 > oab3)){
        return false;
    }
    return true;
}

bool segmentIntersect(vec2 p1, vec2 p2, vec2 p3, vec2 p4, out float t1, out float t2, out vec2 inter)
{
    vec2 r = p2 - p1;
    vec2 s = p4 - p3;

    //cross(r,s)
    float denom = r.x * s.y - r.y * s.x;
    if (abs(denom) < 1e-8)
        return false;

    vec2 diff = p3 - p1;
    t1 = (diff.x * s.y - diff.y * s.x) / denom;
    t2 = (diff.x * r.y - diff.y * r.x) / denom;

    if (t1 >= 0.0 && t1 <= 1.0 && t2 >= 0.0 && t2 <= 1.0) {
        inter = p1 + t1 * r;
        return true;
    }
    return false;
}


bool nearlyEqual(float x, float y)
{
    const float EPSILON = 1e-6;  // 可根据精度需求调整
    return abs(x - y) < EPSILON;
}

bool checkAroundPixel(int picIdx, int px, int py, int targetEdgeIdx){
    //确保周围至少一个自己
    for(int i = -1; i < 2; ++i){
        for(int j = -1; j < 2; ++j){
            if((i == 0) && (j == 0)){
                continue;
            }
            int val = texelFetch(scaleSamples[picIdx], ivec2(px + i, py + j), 0).y;
            if((val == targetEdgeIdx)){
                return true;
            }
        }
    }
    return false;
}

bool pxpyToPixVal(int px, int py, inout int val){
    if(px < 0 || px > IMG_WIDTH * 4 - 1){
        return false;
    }
    if(py < 0 || py > IMG_HEIGHT * 4 - 1){
        return false;
    }
    int picx = px / IMG_WIDTH;
    int picy = py / IMG_HEIGHT;
    int picIdx = picy * 4 + picx;

    int pixx = px - picx * IMG_WIDTH;
    int pixy = py - picy * IMG_HEIGHT;

    val = texelFetch(scaleSamples[picIdx], ivec2(pixx, pixy), 0).y;
    return true;
}

//0：成功，有gloHeID
//1：成功，没有gloHeID
//2：失败，不能判断
int checkPic(vec2 checkProj, int gHeID){
    checkProj = (checkProj + 1.0) * 0.5;
    float x = checkProj.x * IMG_WIDTH * 4;
    float y = checkProj.y * IMG_HEIGHT * 4;
    //float to int，是直接抹除小数部分
    int px = min(int(x), IMG_WIDTH * 4 - 1);
    int py = min(int(y), IMG_HEIGHT * 4 - 1);
    py = IMG_HEIGHT * 4 - 1 - py; //y轴反向

    bool hasGloHeID = false;
    bool noOther = true;
    for(int i = -1; i < 2; ++i){
        for(int j = -1; j < 2; ++j){
            int val;
            if(pxpyToPixVal(px + i, py + j, val)){
                if(val != -1){
                    if(val == gHeID){
                        hasGloHeID = true;
                        return 0;
                    }else{
                        noOther = false;
                    }
                }
            };
        }
    }
    if(noOther){
        return 1;
    }else if(!noOther){
        return 2;
    }
    return 3;
}

//p为顶点，ab为线段
float pointSegmentDistance(vec2 p, vec2 a, vec2 b)
{
    vec2 ab = b - a;
    float abLen2 = dot(ab, ab);
    if (abLen2 == 0.0)
        return length(p - a);  // 线段退化为点

    float t = dot(p - a, ab) / abLen2;
    t = clamp(t, 0.0, 1.0);
    vec2 proj = a + t * ab;
    return length(p - proj);
}

// ------------------------------------------------------------
// 计算两条线段之间的最小距离
// 输入：
//   p1, p2 —— 第一条线段的两个端点
//   q1, q2 —— 第二条线段的两个端点
// 输出：
//   返回两线段之间的最短距离
// 原理：
//   用参数 s, t 分别描述线段上的点：
//     P(s) = p1 + s * (p2 - p1)
//     Q(t) = q1 + t * (q2 - q1)
//   目标是最小化 |P(s) - Q(t)|，在 [0,1]×[0,1] 上寻找最优解。
//   解法参考“最短距离的线段对”公式（几何标准算法）。
// ------------------------------------------------------------
float segmentSegmentDistance(vec2 p1, vec2 p2, vec2 q1, vec2 q2)
{
    vec2 d1 = p2 - p1;     // 第一条线段的方向向量
    vec2 d2 = q2 - q1;     // 第二条线段的方向向量
    vec2 r  = p1 - q1;     // 两条线段起点之间的向量

    float a = dot(d1, d1); // |d1|^2
    float e = dot(d2, d2); // |d2|^2
    float f = dot(d2, r);  // d2·(p1 - q1)

    float s, t;            // 参数 s,t 分别对应 p1→p2 和 q1→q2 的插值比例

    // ---------- 退化情况处理 ----------
    if (a <= 1e-8 && e <= 1e-8) {
        // 两条都退化为点
        return length(p1 - q1);
    }
    if (a <= 1e-8) {
        // 第一条退化为点，第二条是线段
        s = 0.0;
        t = clamp(f / e, 0.0, 1.0);
    } else {
        float c = dot(d1, r);  // d1·(p1 - q1)

        if (e <= 1e-8) {
            // 第二条退化为点
            t = 0.0;
            s = clamp(-c / a, 0.0, 1.0);
        } else {
            // ---------- 一般情况 ----------
            float b = dot(d1, d2);
            float denom = a * e - b * b;  // 行列式，判断两线段是否平行

            // 若不平行，按解析式求出最优 s
            if (denom != 0.0)
                s = clamp((b * f - c * e) / denom, 0.0, 1.0);
            else
                s = 0.0; // 平行时随便取一个，后面再修正

            // 根据 s 求出对应的 t
            float tnom = b * s + f;

            if (tnom < 0.0) {
                // 最近点在 q1 端
                t = 0.0;
                s = clamp(-c / a, 0.0, 1.0);
            } else if (tnom > e) {
                // 最近点在 q2 端
                t = 1.0;
                s = clamp((b - c) / a, 0.0, 1.0);
            } else {
                // 一般情况，s,t 都在段内
                t = tnom / e;
            }
        }
    }

    // ---------- 计算最终最近点 ----------
    vec2 c1 = p1 + d1 * s;  // 第一条线段上最近点
    vec2 c2 = q1 + d2 * t;  // 第二条线段上最近点

    // 返回两点之间的距离
    return length(c1 - c2);
}

// ------------------------------------------------------------
// 两条 3D 线段 p1–p2 与 q1–q2 的最小距离
// 原理：同 2D 版本，只是换成 vec3 向量运算。
// ------------------------------------------------------------
float segmentSegmentDistance3D(vec3 p1, vec3 p2, vec3 q1, vec3 q2)
{
    vec3 d1 = p2 - p1;     // 第一条线段方向
    vec3 d2 = q2 - q1;     // 第二条线段方向
    vec3 r  = p1 - q1;     // 起点间向量

    float a = dot(d1, d1); // |d1|^2
    float e = dot(d2, d2); // |d2|^2
    float f = dot(d2, r);  // d2·(p1 - q1)

    float s, t;            // 参数 s,t 分别对应线段 p 和 q 上的位置

    // ---------- 退化情况处理 ----------
    if (a <= 1e-8 && e <= 1e-8) {
        // 两条都退化为点
        return length(p1 - q1);
    }
    if (a <= 1e-8) {
        // 第一条退化为点
        s = 0.0;
        t = clamp(f / e, 0.0, 1.0);
    } else {
        float c = dot(d1, r);

        if (e <= 1e-8) {
            // 第二条退化为点
            t = 0.0;
            s = clamp(-c / a, 0.0, 1.0);
        } else {
            // ---------- 一般情况 ----------
            float b = dot(d1, d2);
            float denom = a * e - b * b;

            // 非平行情况
            if (denom != 0.0)
                s = clamp((b * f - c * e) / denom, 0.0, 1.0);
            else
                s = 0.0; // 平行时任意选一个，稍后修正 t

            float tnom = b * s + f;
            if (tnom < 0.0) {
                // 最近点在 q1 端
                t = 0.0;
                s = clamp(-c / a, 0.0, 1.0);
            } else if (tnom > e) {
                // 最近点在 q2 端
                t = 1.0;
                s = clamp((b - c) / a, 0.0, 1.0);
            } else {
                // 一般情况：两个参数都在线段内
                t = tnom / e;
            }
        }
    }

    // ---------- 计算对应的最近点 ----------
    vec3 c1 = p1 + d1 * s; // 第一条线段最近点
    vec3 c2 = q1 + d2 * t; // 第二条线段最近点

    // 返回两点间的距离
    return length(c1 - c2);
}

// ================== 工具函数：2D 叉积 ==================
// cross2D(a, b) > 0 : b 在 a 的逆时针方向
// cross2D(a, b) < 0 : b 在 a 的顺时针方向
// cross2D(a, b) = 0 : a 与 b 共线
float cross2D(vec2 a, vec2 b)
{
    return a.x * b.y - a.y * b.x;
}


bool segmentsIntersect(vec2 p1, vec2 p2,
                       vec2 q1, vec2 q2,
                       out vec2 intersection)
{
    const float EPS = 1e-6;

    vec2 r = p2 - p1;
    vec2 s = q2 - q1;

    float rxs     = cross2D(r, s);
    float q_p_x_r = cross2D(q1 - p1, r);

    // 默认输出先设成 0
    intersection = vec2(0.0);

    // 共线
    if (abs(rxs) < EPS && abs(q_p_x_r) < EPS)
    {
        return false;
        // 这里“交点”不唯一，可以根据需要返回某种代表值
        // 例如返回 q1，或者重叠区间中点，这里简单返回 q1
        intersection = q1;
        // 用上面同样的重叠判定
        float r2 = dot(r, r);
        if (r2 < EPS) {
            return length(q1 - p1) < EPS || length(q2 - p1) < EPS;
        }
        float t0 = dot(q1 - p1, r) / r2;
        float t1 = dot(q2 - p1, r) / r2;
        if (t0 > t1) {
            float tmp = t0;
            t0 = t1;
            t1 = tmp;
        }
        return t0 <= 1.0 + EPS && t1 >= 0.0 - EPS;
    }

    // 平行不共线
    if (abs(rxs) < EPS && abs(q_p_x_r) >= EPS)
    {
        return false;
    }

    // 一般情况
    float t = cross2D(q1 - p1, s) / rxs;
    float u = cross2D(q1 - p1, r) / rxs;

    if (t >= 0.0 && t <= 1.0 &&
        u >= 0.0 && u <= 1.0)
    {
        // 只要相交，就用 t 算出交点
        //intersection = p1 + t * r;
        intersection = vec2(t, u);
        return true;
    }

    return false;
}

void findIntersection(int i, int k, out int visChange[MAX_INTER], inout int interCnt, 
    out float ts[MAX_INTER], out int edgeIdx[MAX_INTER], int edgeCnt,
    out int debugFB[MAX_INTER]){

    float t;
    float u;
    vec2 intersection;
    int visChangeVal = 1; //根据edge不同，vis变化也不同

    vec4 mainPos1View = ubo.view * vec4(vertices[i].position,1);
    vec4 mainPos2View = ubo.view * vec4(vertices[i+1].position,1);
    vec4 mainPos1 = ubo.proj * mainPos1View;
    vec4 mainPos2 = ubo.proj * mainPos2View;

    vec4 currPos1View = ubo.view * vec4(vertices[k].position, 1);
    vec4 currPos2View = ubo.view * vec4(vertices[k+1].position, 1);
    vec4 currPos1 = ubo.proj * currPos1View;
    vec4 currPos2 = ubo.proj * currPos2View;

    vec3 fn = mat3(ubo.view) * vertices[k].faceNor;
    vec3 sfn = mat3(ubo.view) * vertices[k].symFaceNor;
    //true为正面，false为反面
    bool currFaceOri = fn.z > 0.0;
    //true表示用了symFace，false表示还是该face
    bool currFaceSym = false;
    //有sym的bEdge
    if(vertices[k].border == 1){
        //如果两个朝向一致，则对于visibility变化无影响
        if(fn.z * sfn.z > 0){
            return;
        }
        //如果皆为平面，不考虑
        if(fn.z == 0 && sfn.z == 0){
            return;
        }
        //如果该面为平面，另一个面不是平面，则切换为另一个面
        if(fn.z == 0){
            currFaceOri = sfn.z > 0.0;
            currFaceSym = true;
        }
        visChangeVal = 2;
    }else if(vertices[k].border == 2){
        visChangeVal = 1;
    }


    if(segmentsIntersect(mainPos1.xy, mainPos2.xy, currPos1.xy, currPos2.xy, intersection)){
        t = intersection.x;
        u = intersection.y;
        if(((t > 1e-3) && (t < (1-1e-3))) && ((u > 1e-3) && (u < (1-1e-3)))){
            float z1 = mainPos1.z * (1-t) + mainPos2.z * t;
            float z2 = currPos1.z * (1-u) + currPos2.z * u;
            
            if(z1 > z2){
                float ee;
                //enter or exit
                if(currFaceSym){
                    ee = cross2D(normalize(mainPos2.xy - mainPos1.xy), normalize(currPos1.xy - currPos2.xy));
                }else{
                    ee = cross2D(normalize(mainPos2.xy - mainPos1.xy), normalize(currPos2.xy - currPos1.xy));
                }
                if(currFaceOri){
                    //curr面为正面
                    if(ee < 0){
                        //进入，可见性-1。
                        visChange[interCnt] = -visChangeVal;
                    }else{
                        //退出，可见性+1。
                        visChange[interCnt] = visChangeVal;
                    }
                    debugFB[interCnt] = 1;
                }else{
                    //curr面为反面
                    if(ee > 0){
                        visChange[interCnt] = -visChangeVal;
                    }else{
                        visChange[interCnt] = visChangeVal;
                    }
                    debugFB[interCnt] = -1;
                }
                debugPrintfEXT("wtf: %f, %f, %d", t, 1e-3, interCnt);
                ts[interCnt] = t;
                edgeIdx[interCnt] = edgeCnt;
                ++interCnt;
            }
        }
    }
}

void visChangeSort(inout int visChange[MAX_INTER], 
    inout float ts[MAX_INTER], out int vis[MAX_INTER + 1], 
    in int edgeIdx[MAX_INTER], in int interCnt){

    vis[0] = 0;

    //根据ts交换visChange
    for (int i = 0; i < interCnt; ++i) {
        for (int j = i + 1; j < interCnt; ++j) {
            if(edgeIdx[j] > edgeIdx[i]){
                continue;
            }
            if (ts[j] < ts[i]) {
                // 交换 ts
                float tmp = ts[i];
                ts[i] = ts[j];
                ts[j] = tmp;

                // 交换 visChange
                int tmp2 = visChange[i];
                visChange[i] = visChange[j];
                visChange[j] = tmp2;
            }
        }
    }

    //计算vis
    for (int i = 0; i < interCnt; ++i) {
        vis[i + 1] = vis[i] + visChange[i];
    }
    //vis最高降低到0
    int maxVis = -10000;
    for (int i = 0; i <= interCnt; ++i) {
        if (vis[i] > maxVis) {
            maxVis = vis[i];
        }
    }
    for (int i = 0; i <= interCnt; ++i) {
        vis[i] -= maxVis;
    }
}

void main() 
{
//    debugPrintfEXT("nh");
//    debugPrintfEXT("index=%d pos=(%.2f, %.2f, %.2f)\n", index1, vertices[0].position.x, vertices[0].position.y, vertices[0].position.z);
//    uint index = gl_GlobalInvocationID.x * 100;
//    for(uint i = 0; i < 100; ++i){
//        uint imgIdx = index / (3840u * 3840u);
//        index = index - (imgIdx * (3840u * 2160u));
//        //pixel coord
//        uint py = index / 3840u;
//        uint px = index - (py * 3840u);
//        int globalHeID = texelFetch(scaleSamples[imgIdx], ivec2(int(px), int(py)), 0).y;
//        if(globalHeID > -1){
//            vertices[globalHeID * 2].debug = 1;
//            vertices[globalHeID * 2 + 1].debug = 1;
//        };
//        index += 1;
//    };


//    uint index = gl_GlobalInvocationID.x;
//    uint imgIdx = index / (3840 * 2160);
//    index = index - (imgIdx * (3840 * 2160));
//    //pixel coord
//    uint py = index / 3840;
//    uint px = index - (py * 3840);
//    float x = py;
//    float y = px;
//    int globalHeID = texelFetch(scaleSamples[imgIdx], ivec2(int(px), int(py)), 0).y;
//    if(globalHeID > -1){
//        vertices[globalHeID * 2].debug = 1;
//        vertices[globalHeID * 2 + 1].debug = 1;
//    };


//    if(gl_GlobalInvocationID.x < targetEdgeCnt){
//        int globalEdgeIdx = targetEdgeIdxList[gl_GlobalInvocationID.x];
//        Vertex v1 = vertices[globalEdgeIdx * 2];
//        Vertex v2 = vertices[globalEdgeIdx * 2 + 1];
//        //vertices[targetEdgeIdx * 2].debug = 1;
//        //vertices[targetEdgeIdx * 2 + 1].debug = 1;
//        vec4 v1PosTmp = ubo.proj * ubo.view * (vec4(v1.position, 1));
//        vec4 v2PosTmp = ubo.proj * ubo.view * (vec4(v2.position, 1));
//        vec3 v1Pos = vec3(v1PosTmp / v1PosTmp.w);
//        vec3 v2Pos = vec3(v2PosTmp / v2PosTmp.w);
//        //AABB的值是clip space的
//        float maxx = targetEdgeAABB[globalEdgeIdx * 4];   //maxx
//        float minx = targetEdgeAABB[globalEdgeIdx * 4 + 1];  //minx
//        float maxy = targetEdgeAABB[globalEdgeIdx * 4 + 2];  //maxy
//        float miny = targetEdgeAABB[globalEdgeIdx * 4 + 3];  //miny
//
//        {
//            float dis = FLOAT_MAX;
//            for(int i = 0; i < targetEdgeCnt; ++i){
//                if(i == gl_GlobalInvocationID.x){
//                    continue;
//                }
//                int currEdgeIdx = targetEdgeIdxList[i];
//                float currMaxx = targetEdgeAABB[currEdgeIdx * 4];   //maxx
//                float currMinx = targetEdgeAABB[currEdgeIdx * 4 + 1];  //minx
//                float currMaxy = targetEdgeAABB[currEdgeIdx * 4 + 2];  //maxy
//                float currMiny = targetEdgeAABB[currEdgeIdx * 4 + 3];  //miny
//                Vertex currV1 = vertices[currEdgeIdx * 2];
//                Vertex currV2 = vertices[currEdgeIdx * 2 + 1];
//                vec4 currV1PosTmp = ubo.proj * ubo.view * (vec4(currV1.position, 1));
//                vec4 currV2PosTmp = ubo.proj * ubo.view * (vec4(currV2.position, 1));
//                vec3 currV1Pos = vec3(currV1PosTmp / currV1PosTmp.w);
//                vec3 currV2Pos = vec3(currV2PosTmp / currV2PosTmp.w);
//                float currDis1 = segmentSegmentDistance3D(v1Pos, v2Pos, currV1Pos, currV2Pos);
//                if(currDis1 < 0.0001f){
//                    continue;
//                }
//                float currDis2 = pointSegmentDistance((v1Pos.xy + v2Pos.xy) * 0.5f, currV1Pos.xy, currV2Pos.xy);
//                if(currDis2 < dis){
//                    dis = currDis2;
//                }
//            }
//            float scale = dis * 10000.f;
//            vertices[globalEdgeIdx * 2].debug = int(scale) + 3;
//            vertices[globalEdgeIdx * 2 + 1].debug = int(scale) + 3;
//        };
//    }

    if(gl_GlobalInvocationID.x < ubo.bEdgeCnt){
        int idxS = bEdgesSE[gl_GlobalInvocationID.x * 2];
        int idxE = bEdgesSE[gl_GlobalInvocationID.x * 2 + 1];
//      一个seg多edge，debug
//        if((idxS > 227220) && (idxS < 227223)){
//            
//        }else{
//            return;
//        }
//        if((idxS > 114100) && (idxS < 114120)){
//
//        }else{
//            return;
//        }
//      无silInterCnt时出错情况
//        if((idxS > 149000) && (idxS < 149200)){
//
//        }else{
//            return;
//        }
//      22964 线隐藏问题（两面覆盖了线，所以导致查询结果是不可见）
//        if((idxS > 22963) && (idxS < 22965)){
//
//        }else{
//            return;
//        }
//      31096 蓝线问题（另一条线刚好交在该线中点，导致没有只查到另一条线）
//      打开depthWriteEnable解决
//        if(idxS > 31095 && idxS < 31097){
//            
//        }else{
//            return;
//        }
//      33094
//      in / out / inout问题
//        if(idxS > 33093 && idxS < 33095){
//
//        }else{
//            return;
//        }
//      85182 
//        if(idxS > 85181 && idxS < 85183){
//            
//        }else{
//            return;
//        }
//      21538    
        if(idxS > 21537 && idxS < 21539){

        }else{
            return;
        }
//      20009 - 39999 检查中
//        if(idxS > 0 && idxS < 20009){
//
//        }else{
//            return;
//        }
        

        int debugFB[MAX_INTER];
        float ts[MAX_INTER];
        int edgeIdx[MAX_INTER];  //记录该inter的edge是seg中的第几个
        int visChange[MAX_INTER];
        int vis[MAX_INTER + 1];
        int interCnt = 0;
        int edgeCnt = 0;  //记录该edge是seg中的第几个
        int silInterCnt = 0;
        for(int i = idxS; i < idxE; i+=2){
            //debug
            if(silInterCnt > 0){
                break;
            }
            for(int j = 0; j < ubo.bEdgeCnt; ++j){
                int currIdxS = bEdgesSE[j * 2];
                int currIdxE = bEdgesSE[j * 2 + 1];
                for(int k = currIdxS; k < currIdxE; k+=2){
                    if(k == i)
                        continue;
                    findIntersection(i, k, visChange, interCnt, ts, edgeIdx, edgeCnt, debugFB);
                }
            }
            for(int j = 0; j < targetEdgeCnt; ++j){
                int gHeID = targetEdgeIdxList[j];
                vertices[gHeID * 2].border = 1;
                vertices[gHeID * 2 + 1].border = 1;
                //debug
                int lastInterCnt = interCnt;
                findIntersection(i, gHeID * 2, visChange, interCnt, ts, edgeIdx, edgeCnt, debugFB);
                if(interCnt > lastInterCnt){
                    ++silInterCnt;
                }
            }
            ++edgeCnt;
        }

        //debug
        if(silInterCnt > 0){
            return;
        }
        debugPrintfEXT("%d", interCnt);
        debugPrintfEXT("edgeIdx: %d, %d, %d, %d", edgeIdx[0], edgeIdx[1], edgeIdx[2], edgeIdx[3]);
        debugPrintfEXT("ts: %.5f, %.5f, %.5f, %.5f", ts[0], ts[1], ts[2], ts[3]);
        debugPrintfEXT("visChange: %d, %d, %d, %d", visChange[0], visChange[1], visChange[2], visChange[3]);
        //现存edge先全部消除
        for(int i = idxS; i < idxE; i+=2){
            vertices[i].debug = 4;
            vertices[i + 1].debug = 4;
        };

        visChangeSort(visChange, ts, vis, edgeIdx, interCnt);
        debugPrintfEXT("vis: %d, %d, %d, %d", vis[0], vis[1], vis[2], vis[3]);

        vec3 renderVers[MAX_BEDGES * 2];
        int renderEdgeIdx = 0;
        int res = -1;

        for(int i = 0; i <= interCnt; ++i){
            if(vis[i] == 0){
                int edgeIdxS;
                int edgeIdxE;
                if(i == 0){
                    edgeIdxS = 0;
                    if(interCnt == 0){
                        edgeIdxE = edgeCnt - 1;
                    }else{
                        edgeIdxE = edgeIdx[0];
                    }
                }else if(i == interCnt){
                    edgeIdxS = edgeIdx[i-1];
                    edgeIdxE = edgeCnt - 1;
                }else{
                    edgeIdxS = edgeIdx[i-1];
                    edgeIdxE = edgeIdx[i];
                }
                
                for(int j = edgeIdxS; j <= edgeIdxE; ++j){
                    int gHeID = vertices[idxS + 2 * j].globalHeID;
                    vec3 pos1;
                    vec3 pos2;

                    if(j == edgeIdxS){
                        if(i == 0){
                            pos1 = vertices[idxS].position;
                        }else{
                            float t1 = ts[i-1];
                            pos1 = (1-t1) * vertices[idxS + 2 * j].position + t1 * vertices[idxS + 2 * j + 1].position;
                        }
                    }else{
                        pos1 = vertices[idxS + 2 * j].position;
                    }

                    if(j == edgeIdxE){
                        if(i == interCnt){
                            pos2 = vertices[idxE - 1].position;
                        }else{
                            float t2 = ts[i];
                            pos2 = (1-t2) * vertices[idxS + 2 * j].position + t2 * vertices[idxS + 2 * j + 1].position;
                        }
                    }else{
                        pos2 = vertices[idxS + 2 * j + 1].position;
                    }
                    renderVers[renderEdgeIdx * 2] = pos1;
                    renderVers[renderEdgeIdx * 2 + 1] = pos2;
                    ++renderEdgeIdx;
                    vec4 pos1Proj = ubo.proj * ubo.view * vec4(pos1,1);
                    vec4 pos2Proj = ubo.proj * ubo.view * vec4(pos2,1);
                    vec2 checkProj = (pos1Proj.xy + pos2Proj.xy) * 0.5;
                    int currRes = -1;
                    //如果是0，跳过checkPic
                    //如果是-1，不能跳过，因为侧影线还没实现，有时候受到侧影线影响会挡住东西
                    if(res == 0){
                        continue;
                    }
                    currRes = checkPic(checkProj, gHeID);
                        
                    if(currRes == 0){
                        res = 0;
                    }
                    if(currRes == 1){
                        res = 1;
                    }
                    if(currRes == 2){
                        if(res == -1){
                            res = 2;
                        }
                    }
                }
            }
        }
        
        if(renderEdgeIdx == 0){
            debugPrintfEXT("renderEdgeIdx == 0");
        }

        if(res == 0){
            for(int i = 0; i < renderEdgeIdx; ++i){
                uint idxOffset = atomicAdd(edgeSuccessCnt, 2);
                vertices[idxOffset + ubo.origEdgeCnt].position = renderVers[i * 2];
                vertices[idxOffset + ubo.origEdgeCnt + 1].position = renderVers[i * 2 + 1];
                vertices[idxOffset + ubo.origEdgeCnt].normal = vec3(1,0,0);
                vertices[idxOffset + ubo.origEdgeCnt + 1].normal = vec3(1,0,0);
                vertices[idxOffset + ubo.origEdgeCnt].debug = 2;
                vertices[idxOffset + ubo.origEdgeCnt + 1].debug = 2;
            }
        }

        if(res == 1){
            for(int i = 0; i < renderEdgeIdx; ++i){
                uint idxOffset = atomicAdd(edgeSuccessCnt, 2);
                vertices[idxOffset + ubo.origEdgeCnt].position = renderVers[i * 2];
                vertices[idxOffset + ubo.origEdgeCnt + 1].position = renderVers[i * 2 + 1];
                vertices[idxOffset + ubo.origEdgeCnt].normal = vec3(0,1,0);
                vertices[idxOffset + ubo.origEdgeCnt + 1].normal = vec3(0,1,0);
                vertices[idxOffset + ubo.origEdgeCnt].debug = 2;
                vertices[idxOffset + ubo.origEdgeCnt + 1].debug = 2;
            }
        }

        if(res == 2){
            for(int i = 0; i < renderEdgeIdx; ++i){
                uint idxOffset = atomicAdd(edgeSuccessCnt, 2);
                vertices[idxOffset + ubo.origEdgeCnt].position = renderVers[i * 2];
                vertices[idxOffset + ubo.origEdgeCnt + 1].position = renderVers[i * 2 + 1];
                vertices[idxOffset + ubo.origEdgeCnt].normal = vec3(0,0,1);
                vertices[idxOffset + ubo.origEdgeCnt + 1].normal = vec3(0,0,1);
                vertices[idxOffset + ubo.origEdgeCnt].debug = 2;
                vertices[idxOffset + ubo.origEdgeCnt + 1].debug = 2;
            }
        }
    }

}