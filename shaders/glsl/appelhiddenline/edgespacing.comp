#version 450
#extension GL_EXT_debug_printf : enable
#define SCALECNT 16
//compute1

struct Vertex{
    vec3 position;
    vec3 normal;
    vec3 faceNor;
    vec3 symFaceNor;
    vec2 uv;
    int objectID;
    int faceID;
    int border;
    int heID;
    int uniqueID;
    int debug;
    int globalHeID;
};

layout (set = 0, binding = 0) uniform isampler2D scaleSamples[SCALECNT]; // 定长数组

layout (set = 0, binding = 1) buffer Vers
{
    //he1 v1, he1 v2, he2 v1, he2 v2,...,
    Vertex vertices[];
};

//uniform和buffer一定不能搞错
layout (set = 0, binding = 2) uniform UBO
{
   mat4 view;
   mat4 proj;
   uint bEdgeCnt;
   uint edgeVertSize;
   uint origEdgeCnt; //现在简单实现用，用于记录加入假edge前有多少edge
}ubo;

layout (set = 0, binding = 3) buffer SBO1
{
   uint targetEdgeCnt;
};

layout (set = 0, binding = 4) buffer SBO2
{
   int targetEdgeIdxList[];
};

layout (set = 0, binding = 5) buffer SBO3
{
   float targetEdgeAABB[];
};

layout (set = 0, binding = 6) buffer SBO4
{
   uint edgeSuccessCnt;
};

layout (set = 0, binding = 7) buffer SBO5
{
   //he1 startIdx, he1 endIdx, he2 startIdx, he2 endIdx,...
   int bEdgesSE[];
};

const float FLOAT_MAX = 3.402823466e+38;

layout (local_size_x = 64) in;

//maxx, minx, maxy, miny
bool twoBBInter(float ab1, float ab2, float ab3, float ab4, float oab1, float oab2, float oab3, float oab4){
    if((ab1 < oab2) || (ab2 > oab1)){
        return false;
    }
    if((ab3 < oab4) || (ab4 > oab3)){
        return false;
    }
    return true;
}

bool segmentIntersect(vec2 p1, vec2 p2, vec2 p3, vec2 p4, out float t1, out float t2, out vec2 inter)
{
    vec2 r = p2 - p1;
    vec2 s = p4 - p3;

    //cross(r,s)
    float denom = r.x * s.y - r.y * s.x;
    if (abs(denom) < 1e-8)
        return false;

    vec2 diff = p3 - p1;
    t1 = (diff.x * s.y - diff.y * s.x) / denom;
    t2 = (diff.x * r.y - diff.y * r.x) / denom;

    if (t1 >= 0.0 && t1 <= 1.0 && t2 >= 0.0 && t2 <= 1.0) {
        inter = p1 + t1 * r;
        return true;
    }
    return false;
}


bool nearlyEqual(float x, float y)
{
    const float EPSILON = 1e-6;  // 可根据精度需求调整
    return abs(x - y) < EPSILON;
}

bool checkAroundPixel(int picIdx, int px, int py, int targetEdgeIdx){
    //确保周围要么是-1，要么是自己
//    for(int i = -1; i < 2; ++i){
//        for(int j = -1; j < 2; ++j){
//            if((i == 0) && (j == 0)){
//                continue;
//            }
//            int val = texelFetch(scaleSamples[picIdx], ivec2(px + i, py + j), 0).y;
//            if((val != -1) && (val != targetEdgeIdx)){
//                return false;
//            }
//        }
//    }
//    return true;
    
    //确保周围至少一个自己
    for(int i = -1; i < 2; ++i){
        for(int j = -1; j < 2; ++j){
            if((i == 0) && (j == 0)){
                continue;
            }
            int val = texelFetch(scaleSamples[picIdx], ivec2(px + i, py + j), 0).y;
            if((val == targetEdgeIdx)){
                return true;
            }
        }
    }
    return false;
}

bool checkPic(ivec2 intPart, vec2 fracPart, int targetEdgeIdx){
    int picIdx = intPart.y * 4 + intPart.x;
    vec2 pxy = fracPart * vec2(3840, 2160);
    //float to int，是直接抹除小数部分
    int px = int(pxy.x);
    int py = int(pxy.y);
    int val = texelFetch(scaleSamples[picIdx], ivec2(px, py), 0).y;

//    if((val == -1) || (val == targetEdgeIdx)){
//        if(checkAroundPixel(picIdx, px, py, targetEdgeIdx)){
//            return true;
//        }
//    }else{
//        return false;
//    }
    if((val == targetEdgeIdx)){
        return true;
    }else{
        if(checkAroundPixel(picIdx, px, py, targetEdgeIdx)){
            return true;
        }
        return false;
    }
}

//p为顶点，ab为线段
float pointSegmentDistance(vec2 p, vec2 a, vec2 b)
{
    vec2 ab = b - a;
    float abLen2 = dot(ab, ab);
    if (abLen2 == 0.0)
        return length(p - a);  // 线段退化为点

    float t = dot(p - a, ab) / abLen2;
    t = clamp(t, 0.0, 1.0);
    vec2 proj = a + t * ab;
    return length(p - proj);
}

// ------------------------------------------------------------
// 计算两条线段之间的最小距离
// 输入：
//   p1, p2 —— 第一条线段的两个端点
//   q1, q2 —— 第二条线段的两个端点
// 输出：
//   返回两线段之间的最短距离
// 原理：
//   用参数 s, t 分别描述线段上的点：
//     P(s) = p1 + s * (p2 - p1)
//     Q(t) = q1 + t * (q2 - q1)
//   目标是最小化 |P(s) - Q(t)|，在 [0,1]×[0,1] 上寻找最优解。
//   解法参考“最短距离的线段对”公式（几何标准算法）。
// ------------------------------------------------------------
float segmentSegmentDistance(vec2 p1, vec2 p2, vec2 q1, vec2 q2)
{
    vec2 d1 = p2 - p1;     // 第一条线段的方向向量
    vec2 d2 = q2 - q1;     // 第二条线段的方向向量
    vec2 r  = p1 - q1;     // 两条线段起点之间的向量

    float a = dot(d1, d1); // |d1|^2
    float e = dot(d2, d2); // |d2|^2
    float f = dot(d2, r);  // d2·(p1 - q1)

    float s, t;            // 参数 s,t 分别对应 p1→p2 和 q1→q2 的插值比例

    // ---------- 退化情况处理 ----------
    if (a <= 1e-8 && e <= 1e-8) {
        // 两条都退化为点
        return length(p1 - q1);
    }
    if (a <= 1e-8) {
        // 第一条退化为点，第二条是线段
        s = 0.0;
        t = clamp(f / e, 0.0, 1.0);
    } else {
        float c = dot(d1, r);  // d1·(p1 - q1)

        if (e <= 1e-8) {
            // 第二条退化为点
            t = 0.0;
            s = clamp(-c / a, 0.0, 1.0);
        } else {
            // ---------- 一般情况 ----------
            float b = dot(d1, d2);
            float denom = a * e - b * b;  // 行列式，判断两线段是否平行

            // 若不平行，按解析式求出最优 s
            if (denom != 0.0)
                s = clamp((b * f - c * e) / denom, 0.0, 1.0);
            else
                s = 0.0; // 平行时随便取一个，后面再修正

            // 根据 s 求出对应的 t
            float tnom = b * s + f;

            if (tnom < 0.0) {
                // 最近点在 q1 端
                t = 0.0;
                s = clamp(-c / a, 0.0, 1.0);
            } else if (tnom > e) {
                // 最近点在 q2 端
                t = 1.0;
                s = clamp((b - c) / a, 0.0, 1.0);
            } else {
                // 一般情况，s,t 都在段内
                t = tnom / e;
            }
        }
    }

    // ---------- 计算最终最近点 ----------
    vec2 c1 = p1 + d1 * s;  // 第一条线段上最近点
    vec2 c2 = q1 + d2 * t;  // 第二条线段上最近点

    // 返回两点之间的距离
    return length(c1 - c2);
}

// ------------------------------------------------------------
// 两条 3D 线段 p1–p2 与 q1–q2 的最小距离
// 原理：同 2D 版本，只是换成 vec3 向量运算。
// ------------------------------------------------------------
float segmentSegmentDistance3D(vec3 p1, vec3 p2, vec3 q1, vec3 q2)
{
    vec3 d1 = p2 - p1;     // 第一条线段方向
    vec3 d2 = q2 - q1;     // 第二条线段方向
    vec3 r  = p1 - q1;     // 起点间向量

    float a = dot(d1, d1); // |d1|^2
    float e = dot(d2, d2); // |d2|^2
    float f = dot(d2, r);  // d2·(p1 - q1)

    float s, t;            // 参数 s,t 分别对应线段 p 和 q 上的位置

    // ---------- 退化情况处理 ----------
    if (a <= 1e-8 && e <= 1e-8) {
        // 两条都退化为点
        return length(p1 - q1);
    }
    if (a <= 1e-8) {
        // 第一条退化为点
        s = 0.0;
        t = clamp(f / e, 0.0, 1.0);
    } else {
        float c = dot(d1, r);

        if (e <= 1e-8) {
            // 第二条退化为点
            t = 0.0;
            s = clamp(-c / a, 0.0, 1.0);
        } else {
            // ---------- 一般情况 ----------
            float b = dot(d1, d2);
            float denom = a * e - b * b;

            // 非平行情况
            if (denom != 0.0)
                s = clamp((b * f - c * e) / denom, 0.0, 1.0);
            else
                s = 0.0; // 平行时任意选一个，稍后修正 t

            float tnom = b * s + f;
            if (tnom < 0.0) {
                // 最近点在 q1 端
                t = 0.0;
                s = clamp(-c / a, 0.0, 1.0);
            } else if (tnom > e) {
                // 最近点在 q2 端
                t = 1.0;
                s = clamp((b - c) / a, 0.0, 1.0);
            } else {
                // 一般情况：两个参数都在线段内
                t = tnom / e;
            }
        }
    }

    // ---------- 计算对应的最近点 ----------
    vec3 c1 = p1 + d1 * s; // 第一条线段最近点
    vec3 c2 = q1 + d2 * t; // 第二条线段最近点

    // 返回两点间的距离
    return length(c1 - c2);
}

// ================== 工具函数：2D 叉积 ==================
// cross2D(a, b) > 0 : b 在 a 的逆时针方向
// cross2D(a, b) < 0 : b 在 a 的顺时针方向
// cross2D(a, b) = 0 : a 与 b 共线
float cross2D(vec2 a, vec2 b)
{
    return a.x * b.y - a.y * b.x;
}


bool segmentsIntersect(vec2 p1, vec2 p2,
                       vec2 q1, vec2 q2,
                       out vec2 intersection)
{
    const float EPS = 1e-6;

    vec2 r = p2 - p1;
    vec2 s = q2 - q1;

    float rxs     = cross2D(r, s);
    float q_p_x_r = cross2D(q1 - p1, r);

    // 默认输出先设成 0
    intersection = vec2(0.0);

    // 共线
    if (abs(rxs) < EPS && abs(q_p_x_r) < EPS)
    {
        return false;
        // 这里“交点”不唯一，可以根据需要返回某种代表值
        // 例如返回 q1，或者重叠区间中点，这里简单返回 q1
        intersection = q1;
        // 用上面同样的重叠判定
        float r2 = dot(r, r);
        if (r2 < EPS) {
            return length(q1 - p1) < EPS || length(q2 - p1) < EPS;
        }
        float t0 = dot(q1 - p1, r) / r2;
        float t1 = dot(q2 - p1, r) / r2;
        if (t0 > t1) {
            float tmp = t0;
            t0 = t1;
            t1 = tmp;
        }
        return t0 <= 1.0 + EPS && t1 >= 0.0 - EPS;
    }

    // 平行不共线
    if (abs(rxs) < EPS && abs(q_p_x_r) >= EPS)
    {
        return false;
    }

    // 一般情况
    float t = cross2D(q1 - p1, s) / rxs;
    float u = cross2D(q1 - p1, r) / rxs;

    if (t >= 0.0 && t <= 1.0 &&
        u >= 0.0 && u <= 1.0)
    {
        // 只要相交，就用 t 算出交点
        //intersection = p1 + t * r;
        intersection = vec2(t, u);
        return true;
    }

    return false;
}

void main() 
{
//    debugPrintfEXT("nh");
//    debugPrintfEXT("index=%u pos=(%.2f, %.2f, %.2f)\n", index1, vertices[0].position.x, vertices[0].position.y, vertices[0].position.z);
//    uint index = gl_GlobalInvocationID.x * 100;
//    for(uint i = 0; i < 100; ++i){
//        uint imgIdx = index / (3840u * 3840u);
//        index = index - (imgIdx * (3840u * 2160u));
//        //pixel coord
//        uint py = index / 3840u;
//        uint px = index - (py * 3840u);
//        int globalHeID = texelFetch(scaleSamples[imgIdx], ivec2(int(px), int(py)), 0).y;
//        if(globalHeID > -1){
//            vertices[globalHeID * 2].debug = 1;
//            vertices[globalHeID * 2 + 1].debug = 1;
//        };
//        index += 1;
//    };


//    uint index = gl_GlobalInvocationID.x;
//    uint imgIdx = index / (3840 * 2160);
//    index = index - (imgIdx * (3840 * 2160));
//    //pixel coord
//    uint py = index / 3840;
//    uint px = index - (py * 3840);
//    float x = py;
//    float y = px;
//    int globalHeID = texelFetch(scaleSamples[imgIdx], ivec2(int(px), int(py)), 0).y;
//    if(globalHeID > -1){
//        vertices[globalHeID * 2].debug = 1;
//        vertices[globalHeID * 2 + 1].debug = 1;
//    };


//    if(gl_GlobalInvocationID.x < targetEdgeCnt){
//        int globalEdgeIdx = targetEdgeIdxList[gl_GlobalInvocationID.x];
//        Vertex v1 = vertices[globalEdgeIdx * 2];
//        Vertex v2 = vertices[globalEdgeIdx * 2 + 1];
//        //vertices[targetEdgeIdx * 2].debug = 1;
//        //vertices[targetEdgeIdx * 2 + 1].debug = 1;
//        vec4 v1PosTmp = ubo.proj * ubo.view * (vec4(v1.position, 1));
//        vec4 v2PosTmp = ubo.proj * ubo.view * (vec4(v2.position, 1));
//        vec3 v1Pos = vec3(v1PosTmp / v1PosTmp.w);
//        vec3 v2Pos = vec3(v2PosTmp / v2PosTmp.w);
//        //AABB的值是clip space的
//        float maxx = targetEdgeAABB[globalEdgeIdx * 4];   //maxx
//        float minx = targetEdgeAABB[globalEdgeIdx * 4 + 1];  //minx
//        float maxy = targetEdgeAABB[globalEdgeIdx * 4 + 2];  //maxy
//        float miny = targetEdgeAABB[globalEdgeIdx * 4 + 3];  //miny
//
//        {
//            float dis = FLOAT_MAX;
//            for(int i = 0; i < targetEdgeCnt; ++i){
//                if(i == gl_GlobalInvocationID.x){
//                    continue;
//                }
//                int currEdgeIdx = targetEdgeIdxList[i];
//                float currMaxx = targetEdgeAABB[currEdgeIdx * 4];   //maxx
//                float currMinx = targetEdgeAABB[currEdgeIdx * 4 + 1];  //minx
//                float currMaxy = targetEdgeAABB[currEdgeIdx * 4 + 2];  //maxy
//                float currMiny = targetEdgeAABB[currEdgeIdx * 4 + 3];  //miny
//                Vertex currV1 = vertices[currEdgeIdx * 2];
//                Vertex currV2 = vertices[currEdgeIdx * 2 + 1];
//                vec4 currV1PosTmp = ubo.proj * ubo.view * (vec4(currV1.position, 1));
//                vec4 currV2PosTmp = ubo.proj * ubo.view * (vec4(currV2.position, 1));
//                vec3 currV1Pos = vec3(currV1PosTmp / currV1PosTmp.w);
//                vec3 currV2Pos = vec3(currV2PosTmp / currV2PosTmp.w);
//                float currDis1 = segmentSegmentDistance3D(v1Pos, v2Pos, currV1Pos, currV2Pos);
//                if(currDis1 < 0.0001f){
//                    continue;
//                }
//                float currDis2 = pointSegmentDistance((v1Pos.xy + v2Pos.xy) * 0.5f, currV1Pos.xy, currV2Pos.xy);
//                if(currDis2 < dis){
//                    dis = currDis2;
//                }
//            }
//            float scale = dis * 10000.f;
//            vertices[globalEdgeIdx * 2].debug = int(scale) + 3;
//            vertices[globalEdgeIdx * 2 + 1].debug = int(scale) + 3;
//        };
//    }

    if(gl_GlobalInvocationID.x < ubo.bEdgeCnt){
        int idxS = bEdgesSE[gl_GlobalInvocationID.x * 2];
        int idxE = bEdgesSE[gl_GlobalInvocationID.x * 2 + 1];
        if((idxS > 269223) && (idxS < 269225)){
            
        }else{
            return;
        }
        //一个seg最多2000个直edge组成，最多10个seg。
        int interIdx[10];
        vec3 interPos[10];
        int visChange[10];
        int interCnt = 0;
        for(int i = idxS; i < idxE; i+=2){
            vec4 mainPos1View = ubo.view * vec4(vertices[i].position,1);
            vec4 mainPos2View = ubo.view * vec4(vertices[i+1].position,1);
            vec4 mainPos1Proj = ubo.proj * mainPos1View;
            vec4 mainPos2Proj = ubo.proj * mainPos2View;
            vec2 mainPos1 = vec2(mainPos1Proj / mainPos1Proj.w);
            vec2 mainPos2 = vec2(mainPos2Proj / mainPos2Proj.w);
            for(int j = 0; j < ubo.bEdgeCnt; ++j){
                int currIdxS = bEdgesSE[j * 2];
                int currIdxE = bEdgesSE[j * 2 + 1];
                for(int k = currIdxS; k < currIdxE; k+=2){
                    if(k == i)
                        continue;
                    vec4 currPos1View = ubo.view * vec4(vertices[k].position, 1);
                    vec4 currPos2View = ubo.view * vec4(vertices[k+1].position, 1);
                    vec4 currPos1Proj = ubo.proj * currPos1View;
                    vec4 currPos2Proj = ubo.proj * currPos2View;
                    vec2 currPos1 = vec2(currPos1Proj / currPos1Proj.w);
                    vec2 currPos2 = vec2(currPos2Proj / currPos2Proj.w);
                    bool isOverlap;
                    float t;
                    float u;

                    vec2 intersection;
                    if(segmentsIntersect(mainPos1, mainPos2, currPos1, currPos2, intersection)){
                        t = intersection.x;
                        u = intersection.y;
                        if(((t > 1e-3) && (t < (1-1e-3))) && ((u > 1e-3) && (u < (1-1e-3)))){
                            float z1 = mainPos1View.z * (1-t) + mainPos2View.z * t;
                            float z2 = currPos1View.z * (1-u) + currPos2View.z * u;
                            if(z1 < z2){
                                //enter or exit
                                float ee = cross2D(normalize(mainPos2 - mainPos1), normalize(currPos2 - currPos1));
                                if((mat3(ubo.view) * vertices[k].faceNor).z < 0){
                                    //curr面为反面
                                    if(ee > 0){
                                        visChange[interCnt] = -1;
                                    }else{
                                        visChange[interCnt] = 1;
                                    }
                                }else{
                                    //curr面为正面
                                    if(ee < 0){
                                        visChange[interCnt] = -1;
                                    }else{
                                        visChange[interCnt] = 1;
                                    }
                                }
                                vertices[k].debug = 2;
                                vertices[k].normal = vec3(1,0,0);
                                vertices[k+1].debug = 2;
                                vertices[k+1].normal = vec3(0,1,0);
                                interIdx[interCnt] = i;
                                interPos[interCnt] = vec3(vertices[i].position * (1-t) + vertices[i+1].position * t);
                                visChange[interCnt] = -3;
                                ++interCnt;
                            }
                        }
                    }
                }
            }
        }
        debugPrintfEXT("index=%u, %u, %u\n",visChange[0], visChange[1], interCnt);
        if(interCnt > 0){
            int vis[11];
            for(int i = 0; i < 11; ++i){
                vis[i] = 0;
            }
            vis[0] = 0;
            for(int i = 0; i < interCnt; ++i){
                vis[i+1] = vis[i] + visChange[i];
            }
            //最高降低到0
            int maxVis = -11;
            for(int i = 0; i <= interCnt; ++i){
                if(vis[i] > maxVis){
                    maxVis = vis[i];
                }
            }
            for(int i = 0; i <= interCnt; ++i){
                vis[i] -= maxVis;
            }
            
            int tempCnt = 0;
            for(int i = idxS; i < idxE; i+=2){
                if(i == interIdx[tempCnt]){
                    vertices[i].debug = 4;
                    vertices[i + 1].debug = 4;
                    
                    if(visChange[tempCnt] == 1){
                        uint idxOffset = atomicAdd(edgeSuccessCnt, 2);
                        vertices[idxOffset + ubo.origEdgeCnt].position = interPos[tempCnt];
                        vertices[idxOffset + ubo.origEdgeCnt + 1].position = vertices[i+1].position;
                        vertices[idxOffset + ubo.origEdgeCnt].normal = vec3(1,0,0);
                        vertices[idxOffset + ubo.origEdgeCnt + 1].normal = vec3(1,0,0);
                        vertices[idxOffset + ubo.origEdgeCnt].debug = 2;
                        vertices[idxOffset + ubo.origEdgeCnt + 1].debug = 2;
                    }
                    if(visChange[tempCnt] == -1){
                        uint idxOffset = atomicAdd(edgeSuccessCnt, 2);
                        vertices[idxOffset + ubo.origEdgeCnt].position = vertices[i].position;
                        vertices[idxOffset + ubo.origEdgeCnt + 1].position = interPos[tempCnt];
                        vertices[idxOffset + ubo.origEdgeCnt].normal = vec3(1,0,0);
                        vertices[idxOffset + ubo.origEdgeCnt + 1].normal = vec3(1,0,0);
                        vertices[idxOffset + ubo.origEdgeCnt].debug = 2;
                        vertices[idxOffset + ubo.origEdgeCnt + 1].debug = 2;
                    }
                    
                    if(tempCnt < (interCnt - 1)){
                        ++tempCnt;
                    }
                }else{
                    if(visChange[tempCnt] == 1){
                    
                    }else{
                        vertices[i].debug = 4;
                        vertices[i + 1].debug = 4;
                    }
                }
            }
        }
    }


//    if(gl_GlobalInvocationID.x < targetEdgeCnt){
//        int globalEdgeIdx = targetEdgeIdxList[gl_GlobalInvocationID.x];
//        Vertex v1 = vertices[globalEdgeIdx * 2];
//        Vertex v2 = vertices[globalEdgeIdx * 2 + 1];
//        //vertices[targetEdgeIdx * 2].debug = 1;
//        //vertices[targetEdgeIdx * 2 + 1].debug = 1;
//        vec4 v1PosTmp = ubo.proj * ubo.view * (vec4(v1.position, 1));
//        vec4 v2PosTmp = ubo.proj * ubo.view * (vec4(v2.position, 1));
//        vec3 v1Pos = vec3(v1PosTmp / v1PosTmp.w);
//        vec3 v2Pos = vec3(v2PosTmp / v2PosTmp.w);
//        //AABB的值是clip space的
//        float maxx = targetEdgeAABB[globalEdgeIdx * 4];   //maxx
//        float minx = targetEdgeAABB[globalEdgeIdx * 4 + 1];  //minx
//        float maxy = targetEdgeAABB[globalEdgeIdx * 4 + 2];  //maxy
//        float miny = targetEdgeAABB[globalEdgeIdx * 4 + 3];  //miny
//
//        {
//            float dis = FLOAT_MAX;
//            for(int i = 0; i < targetEdgeCnt; ++i){
//                if(i == gl_GlobalInvocationID.x){
//                    continue;
//                }
//                int currEdgeIdx = targetEdgeIdxList[i];
//                float currMaxx = targetEdgeAABB[currEdgeIdx * 4];   //maxx
//                float currMinx = targetEdgeAABB[currEdgeIdx * 4 + 1];  //minx
//                float currMaxy = targetEdgeAABB[currEdgeIdx * 4 + 2];  //maxy
//                float currMiny = targetEdgeAABB[currEdgeIdx * 4 + 3];  //miny
//                Vertex currV1 = vertices[currEdgeIdx * 2];
//                Vertex currV2 = vertices[currEdgeIdx * 2 + 1];
//                vec4 currV1PosTmp = ubo.proj * ubo.view * (vec4(currV1.position, 1));
//                vec4 currV2PosTmp = ubo.proj * ubo.view * (vec4(currV2.position, 1));
//                vec3 currV1Pos = vec3(currV1PosTmp / currV1PosTmp.w);
//                vec3 currV2Pos = vec3(currV2PosTmp / currV2PosTmp.w);
//                float currDis1 = segmentSegmentDistance3D(v1Pos, v2Pos, currV1Pos, currV2Pos);
//                if(currDis1 < 0.0001f){
//                    continue;
//                }
//                float currDis2 = pointSegmentDistance((v1Pos.xy + v2Pos.xy) * 0.5f, currV1Pos.xy, currV2Pos.xy);
//                if(currDis2 < dis){
//                    dis = currDis2;
//                }
//            }
//            float scale = dis * 10000.f;
//            vertices[globalEdgeIdx * 2].debug = int(scale) + 3;
//            vertices[globalEdgeIdx * 2 + 1].debug = int(scale) + 3;
//        };
//    }
}

