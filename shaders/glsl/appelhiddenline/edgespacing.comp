#version 450
#extension GL_EXT_debug_printf : enable
#define SCALECNT 16
//compute1

struct Vertex{
    vec3 position;
    vec3 normal;
    vec3 faceNor;
    vec3 symFaceNor;
    vec2 uv;
    int objectID;
    int faceID;
    int border;
    int heID;
    int uniqueID;
    int debug;
    int globalHeID;
};

layout (set = 0, binding = 0) uniform isampler2D scaleSamples[SCALECNT]; // 定长数组

layout (set = 0, binding = 1) buffer Vers
{
    Vertex vertices[];
};

//uniform和buffer一定不能搞错
layout (set = 0, binding = 2) uniform UBO
{
   uint edgeVertSize;
   mat4 view;
   mat4 proj;
}ubo;

layout (set = 0, binding = 3) buffer SBO1
{
   uint targetEdgeCnt;
};

layout (set = 0, binding = 4) buffer SBO2
{
   int targetEdgeIdxList[];
};

layout (set = 0, binding = 5) buffer SBO3
{
   float targetEdgeAABB[];
};

layout (set = 0, binding = 6) buffer SBO4
{
   uint edgeSuccessCnt;
};

const float FLOAT_MAX = 3.402823466e+38;

layout (local_size_x = 64) in;

//maxx, minx, maxy, miny
bool twoBBInter(float ab1, float ab2, float ab3, float ab4, float oab1, float oab2, float oab3, float oab4){
    if((ab1 < oab2) || (ab2 > oab1)){
        return false;
    }
    if((ab3 < oab4) || (ab4 > oab3)){
        return false;
    }
    return true;
}

bool segmentIntersect(vec2 p1, vec2 p2, vec2 p3, vec2 p4, out float t1, out float t2, out vec2 inter)
{
    vec2 r = p2 - p1;
    vec2 s = p4 - p3;

    //cross(r,s)
    float denom = r.x * s.y - r.y * s.x;
    if (abs(denom) < 1e-8)
        return false;

    vec2 diff = p3 - p1;
    t1 = (diff.x * s.y - diff.y * s.x) / denom;
    t2 = (diff.x * r.y - diff.y * r.x) / denom;

    if (t1 >= 0.0 && t1 <= 1.0 && t2 >= 0.0 && t2 <= 1.0) {
        inter = p1 + t1 * r;
        return true;
    }
    return false;
}


bool nearlyEqual(float x, float y)
{
    const float EPSILON = 1e-6;  // 可根据精度需求调整
    return abs(x - y) < EPSILON;
}

bool checkAroundPixel(int picIdx, int px, int py, int targetEdgeIdx){
    //确保周围要么是-1，要么是自己
//    for(int i = -1; i < 2; ++i){
//        for(int j = -1; j < 2; ++j){
//            if((i == 0) && (j == 0)){
//                continue;
//            }
//            int val = texelFetch(scaleSamples[picIdx], ivec2(px + i, py + j), 0).y;
//            if((val != -1) && (val != targetEdgeIdx)){
//                return false;
//            }
//        }
//    }
//    return true;
    
    //确保周围至少一个自己
    for(int i = -1; i < 2; ++i){
        for(int j = -1; j < 2; ++j){
            if((i == 0) && (j == 0)){
                continue;
            }
            int val = texelFetch(scaleSamples[picIdx], ivec2(px + i, py + j), 0).y;
            if((val == targetEdgeIdx)){
                return true;
            }
        }
    }
    return false;
}

bool checkPic(ivec2 intPart, vec2 fracPart, int targetEdgeIdx){
    int picIdx = intPart.y * 4 + intPart.x;
    vec2 pxy = fracPart * vec2(3840, 2160);
    //float to int，是直接抹除小数部分
    int px = int(pxy.x);
    int py = int(pxy.y);
    int val = texelFetch(scaleSamples[picIdx], ivec2(px, py), 0).y;

//    if((val == -1) || (val == targetEdgeIdx)){
//        if(checkAroundPixel(picIdx, px, py, targetEdgeIdx)){
//            return true;
//        }
//    }else{
//        return false;
//    }
    if((val == targetEdgeIdx)){
        return true;
    }else{
        if(checkAroundPixel(picIdx, px, py, targetEdgeIdx)){
            return true;
        }
        return false;
    }
}

//p为顶点，ab为线段
float pointSegmentDistance(vec2 p, vec2 a, vec2 b)
{
    vec2 ab = b - a;
    float abLen2 = dot(ab, ab);
    if (abLen2 == 0.0)
        return length(p - a);  // 线段退化为点

    float t = dot(p - a, ab) / abLen2;
    t = clamp(t, 0.0, 1.0);
    vec2 proj = a + t * ab;
    return length(p - proj);
}

// ------------------------------------------------------------
// 计算两条线段之间的最小距离
// 输入：
//   p1, p2 —— 第一条线段的两个端点
//   q1, q2 —— 第二条线段的两个端点
// 输出：
//   返回两线段之间的最短距离
// 原理：
//   用参数 s, t 分别描述线段上的点：
//     P(s) = p1 + s * (p2 - p1)
//     Q(t) = q1 + t * (q2 - q1)
//   目标是最小化 |P(s) - Q(t)|，在 [0,1]×[0,1] 上寻找最优解。
//   解法参考“最短距离的线段对”公式（几何标准算法）。
// ------------------------------------------------------------
float segmentSegmentDistance(vec2 p1, vec2 p2, vec2 q1, vec2 q2)
{
    vec2 d1 = p2 - p1;     // 第一条线段的方向向量
    vec2 d2 = q2 - q1;     // 第二条线段的方向向量
    vec2 r  = p1 - q1;     // 两条线段起点之间的向量

    float a = dot(d1, d1); // |d1|^2
    float e = dot(d2, d2); // |d2|^2
    float f = dot(d2, r);  // d2·(p1 - q1)

    float s, t;            // 参数 s,t 分别对应 p1→p2 和 q1→q2 的插值比例

    // ---------- 退化情况处理 ----------
    if (a <= 1e-8 && e <= 1e-8) {
        // 两条都退化为点
        return length(p1 - q1);
    }
    if (a <= 1e-8) {
        // 第一条退化为点，第二条是线段
        s = 0.0;
        t = clamp(f / e, 0.0, 1.0);
    } else {
        float c = dot(d1, r);  // d1·(p1 - q1)

        if (e <= 1e-8) {
            // 第二条退化为点
            t = 0.0;
            s = clamp(-c / a, 0.0, 1.0);
        } else {
            // ---------- 一般情况 ----------
            float b = dot(d1, d2);
            float denom = a * e - b * b;  // 行列式，判断两线段是否平行

            // 若不平行，按解析式求出最优 s
            if (denom != 0.0)
                s = clamp((b * f - c * e) / denom, 0.0, 1.0);
            else
                s = 0.0; // 平行时随便取一个，后面再修正

            // 根据 s 求出对应的 t
            float tnom = b * s + f;

            if (tnom < 0.0) {
                // 最近点在 q1 端
                t = 0.0;
                s = clamp(-c / a, 0.0, 1.0);
            } else if (tnom > e) {
                // 最近点在 q2 端
                t = 1.0;
                s = clamp((b - c) / a, 0.0, 1.0);
            } else {
                // 一般情况，s,t 都在段内
                t = tnom / e;
            }
        }
    }

    // ---------- 计算最终最近点 ----------
    vec2 c1 = p1 + d1 * s;  // 第一条线段上最近点
    vec2 c2 = q1 + d2 * t;  // 第二条线段上最近点

    // 返回两点之间的距离
    return length(c1 - c2);
}

// ------------------------------------------------------------
// 两条 3D 线段 p1–p2 与 q1–q2 的最小距离
// 原理：同 2D 版本，只是换成 vec3 向量运算。
// ------------------------------------------------------------
float segmentSegmentDistance3D(vec3 p1, vec3 p2, vec3 q1, vec3 q2)
{
    vec3 d1 = p2 - p1;     // 第一条线段方向
    vec3 d2 = q2 - q1;     // 第二条线段方向
    vec3 r  = p1 - q1;     // 起点间向量

    float a = dot(d1, d1); // |d1|^2
    float e = dot(d2, d2); // |d2|^2
    float f = dot(d2, r);  // d2·(p1 - q1)

    float s, t;            // 参数 s,t 分别对应线段 p 和 q 上的位置

    // ---------- 退化情况处理 ----------
    if (a <= 1e-8 && e <= 1e-8) {
        // 两条都退化为点
        return length(p1 - q1);
    }
    if (a <= 1e-8) {
        // 第一条退化为点
        s = 0.0;
        t = clamp(f / e, 0.0, 1.0);
    } else {
        float c = dot(d1, r);

        if (e <= 1e-8) {
            // 第二条退化为点
            t = 0.0;
            s = clamp(-c / a, 0.0, 1.0);
        } else {
            // ---------- 一般情况 ----------
            float b = dot(d1, d2);
            float denom = a * e - b * b;

            // 非平行情况
            if (denom != 0.0)
                s = clamp((b * f - c * e) / denom, 0.0, 1.0);
            else
                s = 0.0; // 平行时任意选一个，稍后修正 t

            float tnom = b * s + f;
            if (tnom < 0.0) {
                // 最近点在 q1 端
                t = 0.0;
                s = clamp(-c / a, 0.0, 1.0);
            } else if (tnom > e) {
                // 最近点在 q2 端
                t = 1.0;
                s = clamp((b - c) / a, 0.0, 1.0);
            } else {
                // 一般情况：两个参数都在线段内
                t = tnom / e;
            }
        }
    }

    // ---------- 计算对应的最近点 ----------
    vec3 c1 = p1 + d1 * s; // 第一条线段最近点
    vec3 c2 = q1 + d2 * t; // 第二条线段最近点

    // 返回两点间的距离
    return length(c1 - c2);
}

void main() 
{
//    debugPrintfEXT("nh");
//    debugPrintfEXT("index=%u pos=(%.2f, %.2f, %.2f)\n", index1, vertices[0].position.x, vertices[0].position.y, vertices[0].position.z);
//    uint index = gl_GlobalInvocationID.x * 100;
//    for(uint i = 0; i < 100; ++i){
//        uint imgIdx = index / (3840u * 3840u);
//        index = index - (imgIdx * (3840u * 2160u));
//        //pixel coord
//        uint py = index / 3840u;
//        uint px = index - (py * 3840u);
//        int globalHeID = texelFetch(scaleSamples[imgIdx], ivec2(int(px), int(py)), 0).y;
//        if(globalHeID > -1){
//            vertices[globalHeID * 2].debug = 1;
//            vertices[globalHeID * 2 + 1].debug = 1;
//        };
//        index += 1;
//    };


//    uint index = gl_GlobalInvocationID.x;
//    uint imgIdx = index / (3840 * 2160);
//    index = index - (imgIdx * (3840 * 2160));
//    //pixel coord
//    uint py = index / 3840;
//    uint px = index - (py * 3840);
//    float x = py;
//    float y = px;
//    int globalHeID = texelFetch(scaleSamples[imgIdx], ivec2(int(px), int(py)), 0).y;
//    if(globalHeID > -1){
//        vertices[globalHeID * 2].debug = 1;
//        vertices[globalHeID * 2 + 1].debug = 1;
//    };

    if(gl_GlobalInvocationID.x < targetEdgeCnt){
        int globalEdgeIdx = targetEdgeIdxList[gl_GlobalInvocationID.x];
        Vertex v1 = vertices[globalEdgeIdx * 2];
        Vertex v2 = vertices[globalEdgeIdx * 2 + 1];
        //vertices[targetEdgeIdx * 2].debug = 1;
        //vertices[targetEdgeIdx * 2 + 1].debug = 1;
        vec4 v1PosTmp = ubo.proj * ubo.view * (vec4(v1.position, 1));
        vec4 v2PosTmp = ubo.proj * ubo.view * (vec4(v2.position, 1));
        vec3 v1Pos = vec3(v1PosTmp / v1PosTmp.w);
        vec3 v2Pos = vec3(v2PosTmp / v2PosTmp.w);
        //AABB的值是clip space的
        float maxx = targetEdgeAABB[globalEdgeIdx * 4];   //maxx
        float minx = targetEdgeAABB[globalEdgeIdx * 4 + 1];  //minx
        float maxy = targetEdgeAABB[globalEdgeIdx * 4 + 2];  //maxy
        float miny = targetEdgeAABB[globalEdgeIdx * 4 + 3];  //miny

        {
            float dis = FLOAT_MAX;
            for(int i = 0; i < targetEdgeCnt; ++i){
                if(i == gl_GlobalInvocationID.x){
                    continue;
                }
                int currEdgeIdx = targetEdgeIdxList[i];
                float currMaxx = targetEdgeAABB[currEdgeIdx * 4];   //maxx
                float currMinx = targetEdgeAABB[currEdgeIdx * 4 + 1];  //minx
                float currMaxy = targetEdgeAABB[currEdgeIdx * 4 + 2];  //maxy
                float currMiny = targetEdgeAABB[currEdgeIdx * 4 + 3];  //miny
                Vertex currV1 = vertices[currEdgeIdx * 2];
                Vertex currV2 = vertices[currEdgeIdx * 2 + 1];
                vec4 currV1PosTmp = ubo.proj * ubo.view * (vec4(currV1.position, 1));
                vec4 currV2PosTmp = ubo.proj * ubo.view * (vec4(currV2.position, 1));
                vec3 currV1Pos = vec3(currV1PosTmp / currV1PosTmp.w);
                vec3 currV2Pos = vec3(currV2PosTmp / currV2PosTmp.w);
                float currDis1 = segmentSegmentDistance3D(v1Pos, v2Pos, currV1Pos, currV2Pos);
                if(currDis1 < 0.0001f){
                    continue;
                }
                float currDis2 = pointSegmentDistance((v1Pos.xy + v2Pos.xy) * 0.5f, currV1Pos.xy, currV2Pos.xy);
                if(currDis2 < dis){
                    dis = currDis2;
                }
            }
            float scale = dis * 10000.f;
            vertices[globalEdgeIdx * 2].debug = int(scale) + 3;
            vertices[globalEdgeIdx * 2 + 1].debug = int(scale) + 3;
        };


//        if((globalEdgeIdx == 5114)){
//            vertices[globalEdgeIdx * 2].debug = 1;
//            vertices[globalEdgeIdx * 2 + 1].debug = 1;
//            float dis = 1e10;
//            for(int i = 0; i < targetEdgeCnt; ++i){
//                if(i == gl_GlobalInvocationID.x){
//                    continue;
//                }
//                int currEdgeIdx = targetEdgeIdxList[i];
//                float currMaxx = targetEdgeAABB[currEdgeIdx * 4];   //maxx
//                float currMinx = targetEdgeAABB[currEdgeIdx * 4 + 1];  //minx
//                float currMaxy = targetEdgeAABB[currEdgeIdx * 4 + 2];  //maxy
//                float currMiny = targetEdgeAABB[currEdgeIdx * 4 + 3];  //miny
//                Vertex currV1 = vertices[currEdgeIdx * 2];
//                Vertex currV2 = vertices[currEdgeIdx * 2 + 1];
//                vec4 currV1PosTmp = ubo.proj * ubo.view * (vec4(currV1.position, 1));
//                vec4 currV2PosTmp = ubo.proj * ubo.view * (vec4(currV2.position, 1));
//                vec3 currV1Pos = vec3(currV1PosTmp / currV1PosTmp.w);
//                vec3 currV2Pos = vec3(currV2PosTmp / currV2PosTmp.w);
//                float currDis = segmentSegmentDistance(v1Pos.xy, v2Pos.xy, currV1Pos.xy, currV2Pos.xy);
//                if(currDis < 0.0001f){
//                    vertices[currEdgeIdx * 2].debug = 1;
//                    vertices[currEdgeIdx * 2 + 1].debug = 1;
//                    continue;
//                }
//                if(currDis < dis){
//                    dis = currDis;
//                }
//            }
//
//        }

        
        
//        int numInt = 0;
//        float t1s[10];
//        //debugPrintfEXT("pos=(%u, %.5f, %.5f, %.5f, %.5f, %.5f,%.5f,%.5f,%.5f)\n",targetEdgeIdx, v1Pos.x, v1Pos.y, v2Pos.x, v2Pos.y, ab1, ab2, ab3, ab4);
//        for(int i = 0; i < targetEdgeCnt; ++i){
//            if(i == gl_GlobalInvocationID.x){
//                continue;
//            }
//            int currEdgeIdx = targetEdgeIdxList[i];
//            Vertex currv1 = vertices[currEdgeIdx * 2];
//            Vertex currv2 = vertices[currEdgeIdx * 2 + 1];
//            vec3 currv1Pos = vec3(ubo.view * (vec4(currv1.position, 1)));
//            vec3 currv2Pos = vec3(ubo.view * (vec4(currv2.position, 1)));
//            float currab1 = targetEdgeAABB[currEdgeIdx * 4];
//            float currab2 = targetEdgeAABB[currEdgeIdx * 4 + 1];
//            float currab3 = targetEdgeAABB[currEdgeIdx * 4 + 2];
//            float currab4 = targetEdgeAABB[currEdgeIdx * 4 + 3];
//            if(twoBBInter(ab1, ab2, ab3, ab4, currab1, currab2, currab3, currab4)){
//                float t1;
//                float t2;
//                vec2 inter;
//                if(segmentIntersect(v1Pos.xy, v2Pos.xy, currv1Pos.xy, currv2Pos.xy, t1, t2, inter)){
//                    if((nearlyEqual(t1, 0.f) || nearlyEqual(t1, 1.f)) && (nearlyEqual(t2, 0.f) ||nearlyEqual(t2, 1.f))){
//                        //很可能只是首尾相接，或首首，尾尾
//                    }else{
//                        t1s[numInt] = t1;
//                        ++numInt;
//                    }
//                }
//            }
//        }
//        vec3 testPoint = (v1Pos + v2Pos) * 0.5f;
//        vec4 testPoint1 = ubo.proj * vec4(testPoint, 1);
//        testPoint = vec3(testPoint1 / testPoint1.w);
//        vec2 largeUV = (testPoint.xy + vec2(1)) * 2;
//        largeUV.y = 4 - largeUV.y;
//        vec2 intPartf;
//        vec2 fracPart = modf(largeUV, intPartf);
//        ivec2 intPart =  ivec2(intPartf);
//        //debugPrintfEXT("pos=(%u, %.5f, %.5f, %.5f, %.5f, %.5f,%.5f,%.5f,%.5f)\n",targetEdgeIdx, v1Pos.x, v1Pos.y, v2Pos.x, v2Pos.y, largeUV.x,largeUV.y, intPartf.x, intPartf.y);
//        if(checkPic(intPart, fracPart, targetEdgeIdx)){
//            vertices[targetEdgeIdx * 2].debug = 1;
//            vertices[targetEdgeIdx * 2 + 1].debug = 1;
//            atomicAdd(edgeSuccessCnt, 1);
//        }
    }

}

