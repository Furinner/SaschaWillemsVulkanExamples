#version 450
#extension GL_EXT_debug_printf : enable
#define SCALECNT 16
//compute1

const int MAX_INTER = 45;
const int MAX_BEDGES = 300; //一个bSeg最多由多少bEdges组成


const int IMG_WIDTH = 3840;
const int IMG_HEIGHT = 2160;

const int MAX_VER_CNT = 200;
const int MAX_SIL_LINK_CNT = 4;


struct Vertex{
    vec3 position;
    vec3 normal;
    vec3 faceNor;
    vec3 symFaceNor;
    vec2 uv;
    int objectID;
    int faceID;
    int border;
    int heID;
    int uniqueID;
    int debug;
    int globalHeID;  //v1和v2一样，乘以2就变成了vertices2中的idx
    int symUid;  //只有有sym的bEdge有值，其他都是-1
};

layout(push_constant) uniform PushConsts {
	int objNum; 
};

layout (set = 0, binding = 0) uniform isampler2D scaleSamples[SCALECNT]; // 定长数组

layout (set = 0, binding = 1) buffer Vers
{
    //he1 v1, he1 v2, he2 v1, he2 v2,...,
    Vertex vertices[];
};

//uniform和buffer一定不能搞错
layout (set = 0, binding = 2) uniform UBO
{
   mat4 view;
   mat4 proj;
   uint bEdgeCnt; //两个顶点只记一次
   uint edgeVertSize;
   uint origEdgeCnt; //现在简单实现用，用于记录加入假edge前有多少edge
}ubo;

layout (set = 0, binding = 3) buffer SBO1
{
   //边界和silhouette的edge数，两个顶点只记一次
   uint targetEdgeCnt;
};

layout (set = 0, binding = 4) buffer SBO2
{
   //边界和silhouette的edge的globalHeID，两个顶点只记一次
   int targetEdgeIdxList[];
};

layout (set = 0, binding = 5) buffer SBO3
{
   float targetEdgeAABB[];
};

layout (set = 0, binding = 6) buffer SBO4
{
   //从0开始，记录假edge的数量
   uint edgeSuccessCnt;
};

layout (set = 0, binding = 7) buffer SBO5
{
   //he1 startIdx, he1 endIdx, he2 startIdx, he2 endIdx,...
   //有可能startIdx == endIdx，即没有edge，这个要自己判断
   int bEdgesSE[];
};

layout (set = 0, binding = 8) buffer SBO6
{
    int sLinkIntervals[];
};

layout (set = 0, binding = 9) buffer SBO7
{
    int sEdgeIdxs[];
};

layout (set = 0, binding = 10) buffer SBO8
{
	int bEdgeSymObjs[];
};

layout (set = 0, binding = 11) buffer SBO9
{
	int sEdgeOris[];
};

const float FLOAT_MAX = 3.402823466e+38;

layout (local_size_x = 64) in;

//maxx, minx, maxy, miny
bool twoBBInter(float ab1, float ab2, float ab3, float ab4, float oab1, float oab2, float oab3, float oab4){
    if((ab1 < oab2) || (ab2 > oab1)){
        return false;
    }
    if((ab3 < oab4) || (ab4 > oab3)){
        return false;
    }
    return true;
}

bool segmentIntersect(vec2 p1, vec2 p2, vec2 p3, vec2 p4, out float t1, out float t2, out vec2 inter)
{
    vec2 r = p2 - p1;
    vec2 s = p4 - p3;

    //cross(r,s)
    float denom = r.x * s.y - r.y * s.x;
    if (abs(denom) < 1e-8)
        return false;

    vec2 diff = p3 - p1;
    t1 = (diff.x * s.y - diff.y * s.x) / denom;
    t2 = (diff.x * r.y - diff.y * r.x) / denom;

    if (t1 >= 0.0 && t1 <= 1.0 && t2 >= 0.0 && t2 <= 1.0) {
        inter = p1 + t1 * r;
        return true;
    }
    return false;
}


bool nearlyEqual(float x, float y)
{
    const float EPSILON = 1e-6;  // 可根据精度需求调整
    return abs(x - y) < EPSILON;
}

bool checkAroundPixel(int picIdx, int px, int py, int targetEdgeIdx){
    //确保周围至少一个自己
    for(int i = -1; i < 2; ++i){
        for(int j = -1; j < 2; ++j){
            if((i == 0) && (j == 0)){
                continue;
            }
            int val = texelFetch(scaleSamples[picIdx], ivec2(px + i, py + j), 0).y;
            if((val == targetEdgeIdx)){
                return true;
            }
        }
    }
    return false;
}

bool pxpyToPixVal(int px, int py, inout int val){
    if(px < 0 || px > IMG_WIDTH * 4 - 1){
        return false;
    }
    if(py < 0 || py > IMG_HEIGHT * 4 - 1){
        return false;
    }
    int picx = px / IMG_WIDTH;
    int picy = py / IMG_HEIGHT;
    int picIdx = picy * 4 + picx;

    int pixx = px - picx * IMG_WIDTH;
    int pixy = py - picy * IMG_HEIGHT;

    val = texelFetch(scaleSamples[picIdx], ivec2(pixx, pixy), 0).y;
    return true;
}

//0：成功，有gloHeID
//1：成功，没有gloHeID
//2：失败，不能判断
int checkPic(vec2 checkProj, int gHeID){
    checkProj = (checkProj + 1.0) * 0.5;
    float x = checkProj.x * IMG_WIDTH * 4;
    float y = checkProj.y * IMG_HEIGHT * 4;
    //float to int，是直接抹除小数部分
    int px = min(int(x), IMG_WIDTH * 4 - 1);
    int py = min(int(y), IMG_HEIGHT * 4 - 1);
    py = IMG_HEIGHT * 4 - 1 - py; //y轴反向

    bool hasGloHeID = false;
    bool noOther = true;
    for(int i = -1; i < 2; ++i){
        for(int j = -1; j < 2; ++j){
            int val;
            if(pxpyToPixVal(px + i, py + j, val)){
                if(val != -1){
                    if(val == gHeID){
                        hasGloHeID = true;
                        return 0;
                    }else{
                        noOther = false;
                    }
                }
            };
        }
    }
    if(noOther){
        return 1;
    }else if(!noOther){
        return 2;
    }
    return 3;
}

//p为顶点，ab为线段
float pointSegmentDistance(vec2 p, vec2 a, vec2 b)
{
    vec2 ab = b - a;
    float abLen2 = dot(ab, ab);
    if (abLen2 == 0.0)
        return length(p - a);  // 线段退化为点

    float t = dot(p - a, ab) / abLen2;
    t = clamp(t, 0.0, 1.0);
    vec2 proj = a + t * ab;
    return length(p - proj);
}

// ------------------------------------------------------------
// 计算两条线段之间的最小距离
// 输入：
//   p1, p2 —— 第一条线段的两个端点
//   q1, q2 —— 第二条线段的两个端点
// 输出：
//   返回两线段之间的最短距离
// 原理：
//   用参数 s, t 分别描述线段上的点：
//     P(s) = p1 + s * (p2 - p1)
//     Q(t) = q1 + t * (q2 - q1)
//   目标是最小化 |P(s) - Q(t)|，在 [0,1]×[0,1] 上寻找最优解。
//   解法参考“最短距离的线段对”公式（几何标准算法）。
// ------------------------------------------------------------
float segmentSegmentDistance(vec2 p1, vec2 p2, vec2 q1, vec2 q2)
{
    vec2 d1 = p2 - p1;     // 第一条线段的方向向量
    vec2 d2 = q2 - q1;     // 第二条线段的方向向量
    vec2 r  = p1 - q1;     // 两条线段起点之间的向量

    float a = dot(d1, d1); // |d1|^2
    float e = dot(d2, d2); // |d2|^2
    float f = dot(d2, r);  // d2·(p1 - q1)

    float s, t;            // 参数 s,t 分别对应 p1→p2 和 q1→q2 的插值比例

    // ---------- 退化情况处理 ----------
    if (a <= 1e-8 && e <= 1e-8) {
        // 两条都退化为点
        return length(p1 - q1);
    }
    if (a <= 1e-8) {
        // 第一条退化为点，第二条是线段
        s = 0.0;
        t = clamp(f / e, 0.0, 1.0);
    } else {
        float c = dot(d1, r);  // d1·(p1 - q1)

        if (e <= 1e-8) {
            // 第二条退化为点
            t = 0.0;
            s = clamp(-c / a, 0.0, 1.0);
        } else {
            // ---------- 一般情况 ----------
            float b = dot(d1, d2);
            float denom = a * e - b * b;  // 行列式，判断两线段是否平行

            // 若不平行，按解析式求出最优 s
            if (denom != 0.0)
                s = clamp((b * f - c * e) / denom, 0.0, 1.0);
            else
                s = 0.0; // 平行时随便取一个，后面再修正

            // 根据 s 求出对应的 t
            float tnom = b * s + f;

            if (tnom < 0.0) {
                // 最近点在 q1 端
                t = 0.0;
                s = clamp(-c / a, 0.0, 1.0);
            } else if (tnom > e) {
                // 最近点在 q2 端
                t = 1.0;
                s = clamp((b - c) / a, 0.0, 1.0);
            } else {
                // 一般情况，s,t 都在段内
                t = tnom / e;
            }
        }
    }

    // ---------- 计算最终最近点 ----------
    vec2 c1 = p1 + d1 * s;  // 第一条线段上最近点
    vec2 c2 = q1 + d2 * t;  // 第二条线段上最近点

    // 返回两点之间的距离
    return length(c1 - c2);
}

// ------------------------------------------------------------
// 两条 3D 线段 p1–p2 与 q1–q2 的最小距离
// 原理：同 2D 版本，只是换成 vec3 向量运算。
// ------------------------------------------------------------
float segmentSegmentDistance3D(vec3 p1, vec3 p2, vec3 q1, vec3 q2)
{
    vec3 d1 = p2 - p1;     // 第一条线段方向
    vec3 d2 = q2 - q1;     // 第二条线段方向
    vec3 r  = p1 - q1;     // 起点间向量

    float a = dot(d1, d1); // |d1|^2
    float e = dot(d2, d2); // |d2|^2
    float f = dot(d2, r);  // d2·(p1 - q1)

    float s, t;            // 参数 s,t 分别对应线段 p 和 q 上的位置

    // ---------- 退化情况处理 ----------
    if (a <= 1e-8 && e <= 1e-8) {
        // 两条都退化为点
        return length(p1 - q1);
    }
    if (a <= 1e-8) {
        // 第一条退化为点
        s = 0.0;
        t = clamp(f / e, 0.0, 1.0);
    } else {
        float c = dot(d1, r);

        if (e <= 1e-8) {
            // 第二条退化为点
            t = 0.0;
            s = clamp(-c / a, 0.0, 1.0);
        } else {
            // ---------- 一般情况 ----------
            float b = dot(d1, d2);
            float denom = a * e - b * b;

            // 非平行情况
            if (denom != 0.0)
                s = clamp((b * f - c * e) / denom, 0.0, 1.0);
            else
                s = 0.0; // 平行时任意选一个，稍后修正 t

            float tnom = b * s + f;
            if (tnom < 0.0) {
                // 最近点在 q1 端
                t = 0.0;
                s = clamp(-c / a, 0.0, 1.0);
            } else if (tnom > e) {
                // 最近点在 q2 端
                t = 1.0;
                s = clamp((b - c) / a, 0.0, 1.0);
            } else {
                // 一般情况：两个参数都在线段内
                t = tnom / e;
            }
        }
    }

    // ---------- 计算对应的最近点 ----------
    vec3 c1 = p1 + d1 * s; // 第一条线段最近点
    vec3 c2 = q1 + d2 * t; // 第二条线段最近点

    // 返回两点间的距离
    return length(c1 - c2);
}

// ================== 工具函数：2D 叉积 ==================
// cross2D(a, b) > 0 : b 在 a 的逆时针方向
// cross2D(a, b) < 0 : b 在 a 的顺时针方向
// cross2D(a, b) = 0 : a 与 b 共线
float cross2D(vec2 a, vec2 b)
{
    return a.x * b.y - a.y * b.x;
}


bool segmentsIntersect(vec2 p1, vec2 p2,
                       vec2 q1, vec2 q2,
                       out vec2 intersection)
{


    vec2 r = p2 - p1;
    vec2 s = q2 - q1;
    //相对阈值
    const float EPS = 1e-8 * (length(r) * length(s) + 1.0f);

    float rxs     = cross2D(r, s);
    float q_p_x_r = cross2D(q1 - p1, r);

    // 默认输出先设成 0
    intersection = vec2(0.0);

    // 共线
    if (abs(rxs) < EPS && abs(q_p_x_r) < EPS)
    {
        return false;
        // 这里“交点”不唯一，可以根据需要返回某种代表值
        // 例如返回 q1，或者重叠区间中点，这里简单返回 q1
        intersection = q1;
        // 用上面同样的重叠判定
        float r2 = dot(r, r);
        if (r2 < EPS) {
            return length(q1 - p1) < EPS || length(q2 - p1) < EPS;
        }
        float t0 = dot(q1 - p1, r) / r2;
        float t1 = dot(q2 - p1, r) / r2;
        if (t0 > t1) {
            float tmp = t0;
            t0 = t1;
            t1 = tmp;
        }
        return t0 <= 1.0 + EPS && t1 >= 0.0 - EPS;
    }

    // 平行不共线
    if (abs(rxs) < EPS && abs(q_p_x_r) >= EPS)
    {
        return false;
    }

    // 一般情况
    float t = cross2D(q1 - p1, s) / rxs;
    float u = cross2D(q1 - p1, r) / rxs;

    if (t >= 0.0 && t <= 1.0 &&
        u >= 0.0 && u <= 1.0)
    {
        // 只要相交，就用 t 算出交点
        //intersection = p1 + t * r;
        intersection = vec2(t, u);
        return true;
    }

    return false;
}

bool sFindIntersectionB(int idx1, int idx2, int k, out int visChange, out float t){
    float u;
    vec2 intersection;
    int visChangeVal = 1; //根据edge不同，vis变化也不同

    vec4 mainPos1View = ubo.view * vec4(vertices[idx1].position,1);
    vec4 mainPos2View = ubo.view * vec4(vertices[idx2].position,1);
    vec4 mainPos1 = ubo.proj * mainPos1View;
    vec4 mainPos2 = ubo.proj * mainPos2View;

    vec4 currPos1View = ubo.view * vec4(vertices[k].position, 1);
    vec4 currPos2View = ubo.view * vec4(vertices[k+1].position, 1);
    vec4 currPos1 = ubo.proj * currPos1View;
    vec4 currPos2 = ubo.proj * currPos2View;
    
    vec3 fn = mat3(ubo.view) * vertices[k].faceNor;
    vec3 sfn = mat3(ubo.view) * vertices[k].symFaceNor;
    //true为正面，false为反面
    bool currFaceOri = fn.z > 0.0;
    //true表示用了symFace，false表示还是该face
    bool currFaceSym = false;

    //有sym的bEdge
    if(vertices[k].border == 1){
        //如果两个朝向一致，则对于visibility变化无影响
        if(fn.z * sfn.z > 0){
            return false;
        }
        //如果皆为平面，不考虑
        if(fn.z == 0 && sfn.z == 0){
            return false;
        }
        //如果该面为平面，另一个面不是平面，则切换为另一个面
        if(fn.z == 0){
            currFaceOri = sfn.z > 0.0;
            currFaceSym = true;
        }
        visChangeVal = 2;
    }else if(vertices[k].border == 2){
        visChangeVal = 1;
    }

    if(segmentsIntersect(mainPos1.xy, mainPos2.xy, currPos1.xy, currPos2.xy, intersection)){
        t = intersection.x;
        u = intersection.y;
        if(((t > 1e-5) && (t < (1 - 1e-5))) && ((u > 1e-5) && (u < (1 - 1e-5)))){
            float z1 = mainPos1.z * (1-t) + mainPos2.z * t;
            float z2 = currPos1.z * (1-u) + currPos2.z * u;
            if(z1 > z2){
                float ee;
                //enter or exit
                if(currFaceSym){
                    ee = cross2D(normalize(mainPos2.xy - mainPos1.xy), normalize(currPos1.xy - currPos2.xy));
                }else{
                    ee = cross2D(normalize(mainPos2.xy - mainPos1.xy), normalize(currPos2.xy - currPos1.xy));
                }
                if(currFaceOri){
                    //curr面为正面
                    if(ee < 0){
                        //进入，可见性-1。
                        visChange = -visChangeVal;
                    }else{
                        //退出，可见性+1。
                        visChange = visChangeVal;
                    }
                }else{
                    //curr面为反面
                    if(ee > 0){
                        visChange = -visChangeVal;
                    }else{
                        visChange = visChangeVal;
                    }
                }
                return true;
            }else{
                return false;
            }
        }else{
            return false;
        }
    }else{
        return false;
    }
}

bool findIntersectionSilObj(int i, int k1, int k2, bool sameObj, int silOri, out int visChange){
    int b1;
    int b2;
    int s1;
    int s2;
    int idx1;
    int idx2;
    int idx3;
    int idx4;

    if(sameObj){
        b1 = vertices[i].uniqueID;
        b2 = vertices[i + 1].uniqueID;
        idx1 = i;
        idx2 = i + 1;
        idx3 = i + 2;
        idx4 = i + 3;
    }else{
        idx1 = i + 3;
        idx2 = i + 2;
        idx3 = i + 1;
        idx4 = i;
        b1 = vertices[idx1].symUid;
        b2 = vertices[idx2].symUid;
    }
    s1 = vertices[k1].uniqueID;
    s2 = vertices[k2].uniqueID;


    vec3 negEdge;
    vec3 posEdge;
    if(b2 == s1){
        //交于s1，说明从正到反
        negEdge = normalize(mat3(ubo.view) * (vertices[idx4].position - vertices[idx3].position));
        posEdge = normalize(mat3(ubo.view) * (vertices[idx2].position - vertices[idx1].position));
        if(silOri == 1){
            //正sil
            if(cross2D(vec2(posEdge.x, posEdge.y), vec2(negEdge.x, negEdge.y)) > 0){
                //反edge-1
                if(sameObj){
                    visChange = -1;
                }else{
                    visChange = 1;
                }
                return true;
            }
        }else if(silOri == 2){
            //负sil
            if(cross2D(vec2(posEdge.x, posEdge.y), vec2(negEdge.x, negEdge.y)) < 0){
                //反edge+1
                if(sameObj){
                    visChange = 1;
                }else{
                    visChange = -1;
                }
                return true;
            }
        }
    }else if(b2 == s2){
        //交于s2，说明从反到正
        posEdge = normalize(mat3(ubo.view) * (vertices[idx4].position - vertices[idx3].position));
        negEdge = normalize(mat3(ubo.view) * (vertices[idx2].position - vertices[idx1].position));
        if(silOri == 1){
            //正sil
            if(cross2D(vec2(posEdge.x, posEdge.y), vec2(negEdge.x, negEdge.y)) < 0){
                if(sameObj){
                    visChange = 1;
                }else{
                    visChange = -1;
                }
                return true;
            }
        }else if(silOri == 2){
            //负sil
            if(cross2D(vec2(posEdge.x, posEdge.y), vec2(negEdge.x, negEdge.y)) > 0){
                if(sameObj){
                    visChange = -1;
                }else{
                    visChange = 1;
                }
                return true;
            }
        }
    }

    return false;
}

bool findIntersectionSil(int i, int k1, int k2, out int visChange, out float t){
    float u;
    vec2 intersection;
    int visChangeVal = 2; //根据edge不同，vis变化也不同

    vec4 mainPos1View = ubo.view * vec4(vertices[i].position,1);
    vec4 mainPos2View = ubo.view * vec4(vertices[i+1].position,1);
    vec4 mainPos1 = ubo.proj * mainPos1View;
    vec4 mainPos2 = ubo.proj * mainPos2View;

    vec4 currPos1View = ubo.view * vec4(vertices[k1].position, 1);
    vec4 currPos2View = ubo.view * vec4(vertices[k2].position, 1);
    vec4 currPos1 = ubo.proj * currPos1View;
    vec4 currPos2 = ubo.proj * currPos2View;

    if(segmentsIntersect(mainPos1.xy, mainPos2.xy, currPos1.xy, currPos2.xy, intersection)){
        t = intersection.x;
        u = intersection.y;
        if(((t > 1e-5) && (t < (1-1e-5))) && ((u > 1e-5) && (u < (1-1e-5)))){
            float z1 = mainPos1.z * (1-t) + mainPos2.z * t;
            float z2 = currPos1.z * (1-u) + currPos2.z * u;
            
            if(z1 > z2){
                //enter or exit
                float ee = cross2D(normalize(mainPos2.xy - mainPos1.xy), normalize(currPos2.xy - currPos1.xy));
                if(ee < 0){
                    //进入，可见性-1。
                    visChange = -visChangeVal;
                }else{
                    //退出，可见性+1。
                    visChange = visChangeVal;
                }
                return true;
            }else{
                return false;
            }
        }else{
            return false;
        }
    }else{
        return false;
    }
}

bool findIntersection(int i, int k, out int visChange, out float t, out int debugFB, in bool debugInter){

    float u;
    vec2 intersection;
    int visChangeVal = 1; //根据edge不同，vis变化也不同

    vec4 mainPos1View = ubo.view * vec4(vertices[i].position,1);
    vec4 mainPos2View = ubo.view * vec4(vertices[i+1].position,1);
    vec4 mainPos1 = ubo.proj * mainPos1View;
    vec4 mainPos2 = ubo.proj * mainPos2View;

    vec4 currPos1View = ubo.view * vec4(vertices[k].position, 1);
    vec4 currPos2View = ubo.view * vec4(vertices[k+1].position, 1);
    vec4 currPos1 = ubo.proj * currPos1View;
    vec4 currPos2 = ubo.proj * currPos2View;
    
    vec3 fn = mat3(ubo.view) * vertices[k].faceNor;
    vec3 sfn = mat3(ubo.view) * vertices[k].symFaceNor;
    //true为正面，false为反面
    bool currFaceOri = fn.z > 0.0;
    //true表示用了symFace，false表示还是该face
    bool currFaceSym = false;

    //有sym的bEdge
    if(vertices[k].border == 1){
        //如果两个朝向一致，则对于visibility变化无影响
        if(fn.z * sfn.z > 0){
            return false;
        }
        //如果皆为平面，不考虑
        if(fn.z == 0 && sfn.z == 0){
            return false;
        }
        //如果该面为平面，另一个面不是平面，则切换为另一个面
        if(fn.z == 0){
            currFaceOri = sfn.z > 0.0;
            currFaceSym = true;
        }
        visChangeVal = 2;
    }else if(vertices[k].border == 2){
        visChangeVal = 1;
    }

    if(segmentsIntersect(mainPos1.xy, mainPos2.xy, currPos1.xy, currPos2.xy, intersection)){
        t = intersection.x;
        u = intersection.y;
        if(((t > 1e-5) && (t < (1 - 1e-5))) && ((u > 1e-5) && (u < (1 - 1e-5)))){
            float z1 = mainPos1.z * (1-t) + mainPos2.z * t;
            float z2 = currPos1.z * (1-u) + currPos2.z * u;
            if(z1 > z2){
                float ee;
                //enter or exit
                if(currFaceSym){
                    ee = cross2D(normalize(mainPos2.xy - mainPos1.xy), normalize(currPos1.xy - currPos2.xy));
                }else{
                    ee = cross2D(normalize(mainPos2.xy - mainPos1.xy), normalize(currPos2.xy - currPos1.xy));
                }
                if(currFaceOri){
                    //curr面为正面
                    if(ee < 0){
                        //进入，可见性-1。
                        visChange = -visChangeVal;
                    }else{
                        //退出，可见性+1。
                        visChange = visChangeVal;
                    }
                    debugFB = 1;
                }else{
                    //curr面为反面
                    if(ee > 0){
                        visChange = -visChangeVal;
                    }else{
                        visChange = visChangeVal;
                    }
                    debugFB = -1;
                }
                return true;
            }else{
                return false;
            }
        }else{
            return false;
        }
    }else{
        return false;
    }
}

void main() 
{

    if(gl_GlobalInvocationID.x < ubo.bEdgeCnt){
        int idxS = bEdgesSE[gl_GlobalInvocationID.x * 2];
        int idxE = bEdgesSE[gl_GlobalInvocationID.x * 2 + 1];
//      22964 线隐藏问题（两面覆盖了线，所以导致查询结果是不可见）
//        if((idxS > 22963) && (idxS < 22965)){
//
//        }else{
//            return;
//        }
//      31096 蓝线问题（另一条线刚好交在该线中点，导致没有只查到另一条线）
//      打开depthWriteEnable解决
//        if(idxS > 31095 && idxS < 31097){
//            
//        }else{
//            return;
//        }
//      33094，21538  inout传数组问题，
//      删除这类方法以解决
//        if(idxS > 33093 && idxS < 33095){
//
//        }else{
//            return;
//        }
//      63330, 267618 未引入sil，导致没计算出sil交点
//      加入sil解决
//        if(idxS > 267617 && idxS < 267619){
//
//        }else{
//            return;
//        }
//      63316 蓝线问题（缩放不够导致在3x3像素内查到了其他edge）
//        if(idxS > 63315 && idxS < 63317){
//            
//        }else{
//            return;
//        }
//      195754 183304 253136 253226 obj中与sil交
//        if(idxS > 253225 && idxS < 253227){
////            for(int i = idxS; i < idxE; i+=2){
////                vertices[i].debug = 2;
////                vertices[i].normal = vec3(1,0,0);
////                vertices[i + 1].debug = 2;
////                vertices[i + 1].normal = vec3(0,1,0);
////            }
////            int objId = vertices[idxS].objectID;
////            int sliStart = (MAX_SIL_LINK_CNT * 2 + 1) * objId;
////            int seiStart = (MAX_SIL_LINK_CNT * MAX_VER_CNT * 2) * objId;
////            for(int k = 0; k < sLinkIntervals[sliStart]; ++k){
////                for(int l = sLinkIntervals[sliStart + k * 2 + 1]; l < sLinkIntervals[sliStart + k * 2 + 2]; l+=2){
////                    int idx1 = sEdgeIdxs[seiStart + l];
////                    int idx2 = sEdgeIdxs[seiStart + l + 1];
////                    vertices[idx1].debug = 2;
////                    vertices[idx1].normal = vec3(1,0,0);
////                    vertices[idx2].debug = 2;
////                    vertices[idx2].normal = vec3(0,1,0);
////                }
////            }
//        }else{
//            return;
//        }
//      304545  z值相同，需要把边界边在必要时当作sil才可以
//        if(idxS > 304545 && idxS < 304547){
//            for(int i = idxS; i < idxE; i+=2){
//                vertices[i].debug = 2;
//                vertices[i].normal = vec3(1,0,0);
//                vertices[i + 1].debug = 2;
//                vertices[i + 1].normal = vec3(0,1,0);
//            }
//        }else{
//            return;
//        }
//      0 - 359999 检查中

        int debugFB[MAX_INTER];
        float ts[MAX_INTER];
        int edgeIdx[MAX_INTER];  //记录该inter的edge是seg中的第几个
        int visChange[MAX_INTER];
        int vis[MAX_INTER + 1];
        vis[0] = 0;

        int interCnt = 0;
        int edgeCnt = 0;  //记录该edge是seg中的第几个
        for(int i = idxS; i < idxE; i+=2){
            for(int j = 0; j < ubo.bEdgeCnt; ++j){
                int currIdxS = bEdgesSE[j * 2];
                int currIdxE = bEdgesSE[j * 2 + 1];
                for(int k = currIdxS; k < currIdxE; k+=2){
                    if(k == i)
                        continue;
                    float currt;
                    int currDebugFB;
                    int currVisChange;
                    bool debugInter = false;
                    if(findIntersection(i, k, currVisChange, currt, currDebugFB, debugInter)){
//                        vertices[k].debug = 2;
//                        vertices[k + 1].debug = 2;
//                        vertices[k].normal = vec3(1,0,0);
//                        vertices[k + 1].normal = vec3(0,1,0);
                        visChange[interCnt] = currVisChange;
                        ts[interCnt] = currt;
                        debugFB[interCnt] = currDebugFB;
                        edgeIdx[interCnt] = edgeCnt;
                        ++interCnt;
                    }
                }
            }
            for(int j = 0; j < objNum; ++j){
                int sliStart = (MAX_SIL_LINK_CNT * 2 + 1) * j;
                int seiStart = (MAX_SIL_LINK_CNT * MAX_VER_CNT * 2) * j;
                for(int k = 0; k < sLinkIntervals[sliStart]; ++k){
                    for(int l = sLinkIntervals[sliStart + k * 2 + 1]; l < sLinkIntervals[sliStart + k * 2 + 2]; l+=2){
                        int idx1 = sEdgeIdxs[seiStart + l];
                        int idx2 = sEdgeIdxs[seiStart + l + 1];
                        float currt;
                        int currVisChange;
                        if(findIntersectionSil(i, idx1, idx2, currVisChange, currt)){
//                            vertices[idx1].debug = 2;
//                            vertices[idx2].debug = 2;
//                            vertices[idx1].normal = vec3(1,0,0);
//                            vertices[idx2].normal = vec3(0,1,0);
                            visChange[interCnt] = currVisChange;
                            ts[interCnt] = currt;
                            edgeIdx[interCnt] = edgeCnt;
                            ++interCnt;
                        }
                    }
                }
            }
            ++edgeCnt;
        }
        
        //与sil在obj上交
        int objId = vertices[idxS].objectID;
        int symObjId = bEdgeSymObjs[gl_GlobalInvocationID.x];
        {
            int sliStart = (MAX_SIL_LINK_CNT * 2 + 1) * objId;
            if(sLinkIntervals[sliStart] > 0){
                int edgeCnt = 0;
                for(int i = idxS; i < idxE; i+=2){
                    int seiStart = (MAX_SIL_LINK_CNT * MAX_VER_CNT * 2) * objId;
                    int seoStart = (MAX_SIL_LINK_CNT * MAX_VER_CNT) * objId;
                    for(int k = 0; k < sLinkIntervals[sliStart]; ++k){
                        for(int l = sLinkIntervals[sliStart + k * 2 + 1]; l < sLinkIntervals[sliStart + k * 2 + 2]; l+=2){
                            int idx1 = sEdgeIdxs[seiStart + l];
                            int idx2 = sEdgeIdxs[seiStart + l + 1];
                            int visC;
                            if(findIntersectionSilObj(i, idx1, idx2, true, sEdgeOris[seoStart + l / 2], visC)){
                                visChange[interCnt] = visC;
                                ts[interCnt] = 1.0;
                                edgeIdx[interCnt] = edgeCnt;
                                ++interCnt;
                            };
                        }
                    }
                    ++edgeCnt;
                }
            }
        }
        {
            if(symObjId != -1){
                int sliStart = (MAX_SIL_LINK_CNT * 2 + 1) * symObjId;
                if(sLinkIntervals[sliStart] > 0){
                    int edgeCnt = 0;
                    for(int i = idxS; i < idxE; i+=2){
                        int seiStart = (MAX_SIL_LINK_CNT * MAX_VER_CNT * 2) * symObjId;
                        int seoStart = (MAX_SIL_LINK_CNT * MAX_VER_CNT) * symObjId;
                        for(int k = 0; k < sLinkIntervals[sliStart]; ++k){
                            for(int l = sLinkIntervals[sliStart + k * 2 + 1]; l < sLinkIntervals[sliStart + k * 2 + 2]; l+=2){
                                int idx1 = sEdgeIdxs[seiStart + l];
                                int idx2 = sEdgeIdxs[seiStart + l + 1];
                                int visC;
                                if(findIntersectionSilObj(i, idx1, idx2, false, sEdgeOris[seoStart + l / 2], visC)){
                                    visChange[interCnt] = visC;
                                    ts[interCnt] = 1.0;
                                    edgeIdx[interCnt] = edgeCnt;
                                    ++interCnt;
                                };
                            }
                        }
                        ++edgeCnt;
                    }
                }
            }
        }

        //visChangeSort
        for (int i = 0; i < interCnt; ++i) {
            for (int j = i + 1; j < interCnt; ++j) {
                if(edgeIdx[j] > edgeIdx[i]){
                    continue;
                }
                if (ts[j] < ts[i]) {
                    // 交换 ts
                    float tmp = ts[i];
                    ts[i] = ts[j];
                    ts[j] = tmp;
                    // 交换 visChange
                    int tmp2 = visChange[i];
                    visChange[i] = visChange[j];
                    visChange[j] = tmp2;
                }
            }
        }
        for (int i = 0; i < interCnt; ++i) {
            vis[i + 1] = vis[i] + visChange[i];
        }
        int maxVis = -10000;
        for (int i = 0; i <= interCnt; ++i) {
            if (vis[i] > maxVis) {
                maxVis = vis[i];
            }
        }
        for (int i = 0; i <= interCnt; ++i) {
            vis[i] -= maxVis;
        }

        //现存edge先全部消除
        for(int i = idxS; i < idxE; i+=2){
            vertices[i].debug = 4;
            vertices[i + 1].debug = 4;
        }
        
        //render
        vec3 renderVers[MAX_BEDGES * 2];
        int renderEdgeIdx = 0;
        int res = -1;

        for(int i = 0; i <= interCnt; ++i){
            if(vis[i] == 0){
                int edgeIdxS;
                int edgeIdxE;
                if(i == 0){
                    edgeIdxS = 0;
                    if(interCnt == 0){
                        edgeIdxE = edgeCnt - 1;
                    }else{
                        edgeIdxE = edgeIdx[0];
                    }
                }else if(i == interCnt){
                    edgeIdxS = edgeIdx[i-1];
                    edgeIdxE = edgeCnt - 1;
                }else{
                    edgeIdxS = edgeIdx[i-1];
                    edgeIdxE = edgeIdx[i];
                }
                
                for(int j = edgeIdxS; j <= edgeIdxE; ++j){
                    int gHeID = vertices[idxS + 2 * j].globalHeID;
                    vec3 pos1;
                    vec3 pos2;

                    if(j == edgeIdxS){
                        if(i == 0){
                            pos1 = vertices[idxS].position;
                        }else{
                            float t1 = ts[i-1];
                            pos1 = (1-t1) * vertices[idxS + 2 * j].position + t1 * vertices[idxS + 2 * j + 1].position;
                        }
                    }else{
                        pos1 = vertices[idxS + 2 * j].position;
                    }

                    if(j == edgeIdxE){
                        if(i == interCnt){
                            pos2 = vertices[idxE - 1].position;
                        }else{
                            float t2 = ts[i];
                            pos2 = (1-t2) * vertices[idxS + 2 * j].position + t2 * vertices[idxS + 2 * j + 1].position;
                        }
                    }else{
                        pos2 = vertices[idxS + 2 * j + 1].position;
                    }
                    renderVers[renderEdgeIdx * 2] = pos1;
                    renderVers[renderEdgeIdx * 2 + 1] = pos2;
                    ++renderEdgeIdx;
                    vec4 pos1Proj = ubo.proj * ubo.view * vec4(pos1,1);
                    vec4 pos2Proj = ubo.proj * ubo.view * vec4(pos2,1);
                    vec2 checkProj = (pos1Proj.xy + pos2Proj.xy) * 0.5;
                    int currRes = -1;
                    //如果是0，跳过checkPic
                    //如果是-1，不能跳过，因为侧影线还没实现，有时候受到侧影线影响会挡住东西
                    if(res == 0){
                        continue;
                    }
                    currRes = checkPic(checkProj, gHeID);
                        
                    if(currRes == 0){
                        res = 0;
                    }
                    if(currRes == 1){
                        res = 1;
                    }
                    if(currRes == 2){
                        if(res == -1){
                            res = 2;
                        }
                    }
                }
            }
        }
        if(res == 0){
            for(int i = 0; i < renderEdgeIdx; ++i){
                uint idxOffset = atomicAdd(edgeSuccessCnt, 2);
                vertices[idxOffset + ubo.origEdgeCnt * 2].position = renderVers[i * 2];
                vertices[idxOffset + ubo.origEdgeCnt * 2 + 1].position = renderVers[i * 2 + 1];
                vertices[idxOffset + ubo.origEdgeCnt * 2].normal = vec3(1,0,0);
                vertices[idxOffset + ubo.origEdgeCnt * 2 + 1].normal = vec3(1,0,0);
                vertices[idxOffset + ubo.origEdgeCnt * 2].debug = 2;
                vertices[idxOffset + ubo.origEdgeCnt * 2 + 1].debug = 2;
            }
        }
    }

    if(gl_GlobalInvocationID.x < objNum){
        int objId = int(gl_GlobalInvocationID.x);
    
        int sliStart = (MAX_SIL_LINK_CNT * 2 + 1) * objId;
        int seiStart = (MAX_SIL_LINK_CNT * MAX_VER_CNT * 2) * objId;
        if(sLinkIntervals[sliStart] > 0){
            for(int sLinkCnt = 0; sLinkCnt < sLinkIntervals[sliStart]; ++sLinkCnt){
                int edgeCnt = 0;
                int interCnt = 0;
                float ts[MAX_INTER];
                int edgeIdx[MAX_INTER];  //记录该inter的edge是seg中的第几个
                int visChange[MAX_INTER];
                int vis[MAX_INTER + 1];
                vis[0] = 0;

                int idxS = seiStart + sLinkIntervals[sliStart + sLinkCnt * 2 + 1];
                int idxE = seiStart + sLinkIntervals[sliStart + sLinkCnt * 2 + 2];

                for(int l = idxS; l < idxE; l+=2){
                    int idx1 = sEdgeIdxs[l];
                    int idx2 = sEdgeIdxs[l + 1];
                    vertices[idx1].debug = 2;
                    vertices[idx2].debug = 2;
                    vertices[idx1].normal = vec3(1,0,0);
                    vertices[idx2].normal = vec3(0,1,0);
                    int visC;
                    float t;
                    for(int j = 0; j < ubo.bEdgeCnt; ++j){
                        int currIdxS = bEdgesSE[j * 2];
                        int currIdxE = bEdgesSE[j * 2 + 1];
                        for(int k = currIdxS; k < currIdxE; k+=2){
                            if(sFindIntersectionB(idx1, idx2, k, visC, t)){
                                visChange[interCnt] = visC;
                                ts[interCnt] = t;
                                edgeIdx[interCnt] = edgeCnt;
                                ++interCnt;
                            }
                        }
                    }
                    ++edgeCnt;
                }
                //visChangeSort
                for (int i = 0; i < interCnt; ++i) {
                    for (int j = i + 1; j < interCnt; ++j) {
                        if(edgeIdx[j] > edgeIdx[i]){
                            continue;
                        }
                        if (ts[j] < ts[i]) {
                            // 交换 ts
                            float tmp = ts[i];
                            ts[i] = ts[j];
                            ts[j] = tmp;
                            // 交换 visChange
                            int tmp2 = visChange[i];
                            visChange[i] = visChange[j];
                            visChange[j] = tmp2;
                        }
                    }
                }
                for (int i = 0; i < interCnt; ++i) {
                    vis[i + 1] = vis[i] + visChange[i];
                }
                int maxVis = -10000;
                for (int i = 0; i <= interCnt; ++i) {
                    if (vis[i] > maxVis) {
                        maxVis = vis[i];
                    }
                }
                for (int i = 0; i <= interCnt; ++i) {
                    vis[i] -= maxVis;
                }

                //现存edge先全部消除
                for(int l = idxS; l < idxE; l+=2){
                    int idx1 = sEdgeIdxs[l];
                    int idx2 = sEdgeIdxs[l + 1];
                    vertices[idx1].debug = 4;
                    vertices[idx2].debug = 4;
                }

                //render
                vec3 renderVers[MAX_BEDGES * 2];
                int renderEdgeIdx = 0;
                int res = -1;

                for(int i = 0; i <= interCnt; ++i){
                    if(vis[i] == 0){
                        int edgeIdxS;
                        int edgeIdxE;
                        if(i == 0){
                            edgeIdxS = 0;
                            if(interCnt == 0){
                                edgeIdxE = edgeCnt - 1;
                            }else{
                                edgeIdxE = edgeIdx[0];
                            }
                        }else if(i == interCnt){
                            edgeIdxS = edgeIdx[i-1];
                            edgeIdxE = edgeCnt - 1;
                        }else{
                            edgeIdxS = edgeIdx[i-1];
                            edgeIdxE = edgeIdx[i];
                        }
                        for(int j = edgeIdxS; j <= edgeIdxE; ++j){
                            int gHeID = vertices[sEdgeIdxs[idxS + 2 * j]].globalHeID;
                            vec3 pos1;
                            vec3 pos2;

                            if(j == edgeIdxS){
                                if(i == 0){
                                    pos1 = vertices[sEdgeIdxs[idxS]].position;
                                }else{
                                    float t1 = ts[i-1];
                                    pos1 = (1-t1) * vertices[sEdgeIdxs[idxS + 2 * j]].position + t1 * vertices[sEdgeIdxs[idxS + 2 * j + 1]].position;
                                }
                            }else{
                                pos1 = vertices[sEdgeIdxs[idxS + 2 * j]].position;
                            }

                            if(j == edgeIdxE){
                                if(i == interCnt){
                                    pos2 = vertices[sEdgeIdxs[idxE - 1]].position;
                                }else{
                                    float t2 = ts[i];
                                    pos2 = (1-t2) * vertices[sEdgeIdxs[idxS + 2 * j]].position + t2 * vertices[sEdgeIdxs[idxS + 2 * j + 1]].position;
                                }
                            }else{
                                pos2 = vertices[sEdgeIdxs[idxS + 2 * j + 1]].position;
                            }
                            renderVers[renderEdgeIdx * 2] = pos1;
                            renderVers[renderEdgeIdx * 2 + 1] = pos2;
                            ++renderEdgeIdx;
                            vec4 pos1Proj = ubo.proj * ubo.view * vec4(pos1,1);
                            vec4 pos2Proj = ubo.proj * ubo.view * vec4(pos2,1);
                            vec2 checkProj = (pos1Proj.xy + pos2Proj.xy) * 0.5;
                            int currRes = -1;
                            //如果是0，跳过checkPic
                            //如果是-1，不能跳过，因为侧影线还没实现，有时候受到侧影线影响会挡住东西
                            if(res == 0){
                                continue;
                            }
                            currRes = checkPic(checkProj, gHeID);
                    
                            if(currRes == 0){
                                res = 0;
                            }
                            if(currRes == 1){
                                res = 1;
                            }
                            if(currRes == 2){
                                if(res == -1){
                                    res = 2;
                                }
                            }
                        }
                    }
                }

                if(res == 0){
                    for(int i = 0; i < renderEdgeIdx; ++i){
                        uint idxOffset = atomicAdd(edgeSuccessCnt, 2);
                        vertices[idxOffset + ubo.origEdgeCnt * 2].position = renderVers[i * 2];
                        vertices[idxOffset + ubo.origEdgeCnt * 2 + 1].position = renderVers[i * 2 + 1];
                        vertices[idxOffset + ubo.origEdgeCnt * 2].normal = vec3(1,0,0);
                        vertices[idxOffset + ubo.origEdgeCnt * 2 + 1].normal = vec3(1,0,0);
                        vertices[idxOffset + ubo.origEdgeCnt * 2].debug = 2;
                        vertices[idxOffset + ubo.origEdgeCnt * 2 + 1].debug = 2;
                    }
                }
            }
        }
    }
}